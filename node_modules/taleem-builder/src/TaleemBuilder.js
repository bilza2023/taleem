import { validateDeckV1 } from "taleem-core";

/* ────────────────────────────────────────────── */
/* Slide registry                                 */
/* ────────────────────────────────────────────── */

const SLIDE_TYPES = [
  "eq",
  "titleSlide",
  "titleAndSubtitle",
  "titleAndPara",
  "bulletList",
  "twoColumnText",
  "imageSlide",
  "imageWithTitle",
  "imageWithCaption",
  "imageLeftBulletsRight",
  "imageRightBulletsLeft",
  "table",
  "statistic",
  "donutChart",
  "bigNumber",
  "barChart",
  "quoteSlide",
  "quoteWithImage",
  "cornerWordsSlide",
  "contactSlide",
  "fillImage"
];

/* ────────────────────────────────────────────── */
/* Mobile policy (compile-time)                   */
/* ────────────────────────────────────────────── */

const MOBILE_UNSAFE_SLIDES = new Set([
  "twoColumnText",
  "table",
  "barChart",
  "donutChart"
]);

/* ────────────────────────────────────────────── */
/* Builder                                        */
/* ────────────────────────────────────────────── */

export default class TaleemBuilder {
  constructor({ mode = "desktop" } = {}) {
    this.mode = mode;

    this.slides = [];
    this.currentTime = 0;

    this.details = { name: "unnamed_deck" };

    this.background = {
      backgroundColor: "#F3E5AB",
      backgroundImage: "/images/taleem.webp",
      backgroundImageOpacity: 0.07
    };

    /* expose slide language */
    SLIDE_TYPES.forEach(type => {
      this[type] = (end, data, options = {}) =>
        this.#addSlide(type, end, data, options);
    });
  }

  /* ────── metadata ────── */

  addDetails(meta) {
    this.details = { ...this.details, ...meta };
  }

  setBackgroundImage(url) {
    this.background.backgroundImage = url;
  }

  setBackgroundColor(color) {
    this.background.backgroundColor = color;
  }

  setBackgroundOpacity(val) {
    this.background.backgroundImageOpacity = val;
  }

  /* ────── slide insertion ────── */

  #addSlide(type, end, data, options) {
    const start = this.currentTime;

    if (end <= start) {
      throw new Error(
        `Slide "${type}" ends (${end}) before it starts (${start}).`
      );
    }

    /* mobile policy enforcement */
    if (this.mode === "mobile" && MOBILE_UNSAFE_SLIDES.has(type)) {
      throw new Error(`Slide "${type}" is not allowed in mobile mode`);
    }

    this.slides.push({ type, start, end, data, ...options });
    this.currentTime = end;
  }

  /* ────── EQ compiler pass ────── */

  #compileEqData(flatData) {
    const lines = [];
    let currentLine = null;

    for (const item of flatData) {
      /* main line */
      if (item.type === "math" || item.type === "text" || item.type === "heading") {
        currentLine = {
          name: "line",
          type: item.type,
          content: item.content,
          showAt: item.showAt,
          spItems: []
        };
        lines.push(currentLine);
        continue;
      }

      /* sidebar item */
      if (item.type?.startsWith("sp")) {
        if (!currentLine) {
          throw new Error("EQ sidebar item found before any line");
        }
        currentLine.spItems.push({
          type: item.type,
          content: item.content
        });
        continue;
      }

      throw new Error(`Unknown EQ item type: ${item.type}`);
    }

    return lines;
  }

  /* ────── build targets ────── */

  buildJSON() {
    /* compile passes */
    const compiledSlides = this.slides.map(slide => {
      if (slide.type === "eq") {
        return {
          ...slide,
          data: this.#compileEqData(slide.data)
        };
      }
      return slide;
    });

    const deck = {
      ...this.details,
      version: "deck-v1",
      background: this.background,
      deck: compiledSlides
    };

    /* validate against canonical schema */
    const res = validateDeckV1(deck);
    if (!res.ok) {
      throw new Error(
        "Deck validation failed:\n" +
        JSON.stringify(res.errors, null, 2)
      );
    }

    return res.value;
  }

  build() {
    return this.buildJSON();
  }
}
