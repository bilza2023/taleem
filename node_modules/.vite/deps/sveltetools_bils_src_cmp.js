import "./chunk-AYNHEKRI.js";
import {
  fade
} from "./chunk-RXLEV75D.js";
import "./chunk-ETWSND26.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  create_component,
  create_in_transition,
  create_out_transition,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_svelte_dataset,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  space,
  src_url_equal,
  text,
  to_number,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-UU6HQWOC.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-EQCVQC35.js";

// node_modules/sveltetools_bils/src/cmp/Anchor.svelte
var file = "node_modules/sveltetools_bils/src/cmp/Anchor.svelte";
function create_fragment(ctx) {
  let div1;
  let div0;
  let a;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      a = claim_element(div0_nodes, "A", { href: true });
      var a_nodes = children(a);
      if (default_slot) default_slot.l(a_nodes);
      a_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[0]
      );
      add_location(a, file, 10, 8, 188);
      attr_dev(div0, "class", "text-xl");
      add_location(div0, file, 9, 4, 158);
      attr_dev(div1, "class", "flex justify-center p-1 m-1 bg-gray-800 text-white rounded-md border-2 border-slate-700 mx-10");
      add_location(div1, file, 6, 0, 44);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, a);
      if (default_slot) {
        default_slot.m(a, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*href*/
      1) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[0]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Anchor", slots, ["default"]);
  let { href = "" } = $$props;
  const writable_props = ["href"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Anchor> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("href" in $$props2) $$invalidate(0, href = $$props2.href);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ href });
  $$self.$inject_state = ($$props2) => {
    if ("href" in $$props2) $$invalidate(0, href = $$props2.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [href, $$scope, slots];
}
var Anchor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { href: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor",
      options,
      id: create_fragment.name
    });
  }
  get href() {
    throw new Error("<Anchor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Anchor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Anchor_default = Anchor;

// node_modules/sveltetools_bils/src/cmp/AnchorIconOval.svelte
var file2 = "node_modules/sveltetools_bils/src/cmp/AnchorIconOval.svelte";
function create_fragment2(ctx) {
  let div;
  let a;
  let span;
  let t;
  let span_class_value;
  let a_class_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      span = element("span");
      t = text(
        /*icon*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = `${/*textSize*/
      ctx[2]}`);
      add_location(span, file2, 12, 4, 304);
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[3]
      );
      attr_dev(a, "class", a_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`);
      add_location(a, file2, 8, 2, 180);
      attr_dev(div, "class", "flex justify-center");
      add_location(div, file2, 7, 0, 144);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      1) set_data_dev(
        t,
        /*icon*/
        ctx2[0]
      );
      if (dirty & /*textSize*/
      4 && span_class_value !== (span_class_value = `${/*textSize*/
      ctx2[2]}`)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*href*/
      8) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[3]
        );
      }
      if (dirty & /*bgColor*/
      2 && a_class_value !== (a_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx2[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`)) {
        attr_dev(a, "class", a_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorIconOval", slots, []);
  let { icon = "⚙️" } = $$props;
  let { bgColor = "bg-gray-700" } = $$props;
  let { textSize = "text-sm" } = $$props;
  let { href = "#" } = $$props;
  const writable_props = ["icon", "bgColor", "textSize", "href"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AnchorIconOval> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("textSize" in $$props2) $$invalidate(2, textSize = $$props2.textSize);
    if ("href" in $$props2) $$invalidate(3, href = $$props2.href);
  };
  $$self.$capture_state = () => ({ icon, bgColor, textSize, href });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("textSize" in $$props2) $$invalidate(2, textSize = $$props2.textSize);
    if ("href" in $$props2) $$invalidate(3, href = $$props2.href);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, textSize, href];
}
var AnchorIconOval = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      icon: 0,
      bgColor: 1,
      textSize: 2,
      href: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorIconOval",
      options,
      id: create_fragment2.name
    });
  }
  get icon() {
    throw new Error("<AnchorIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<AnchorIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<AnchorIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<AnchorIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textSize() {
    throw new Error("<AnchorIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textSize(value) {
    throw new Error("<AnchorIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<AnchorIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<AnchorIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorIconOval_default = AnchorIconOval;

// node_modules/sveltetools_bils/src/cmp/AreYouSure.svelte
var file3 = "node_modules/sveltetools_bils/src/cmp/AreYouSure.svelte";
function add_css(target) {
  append_styles(target, "svelte-1vqnce", ".fixed-size.svelte-1vqnce{width:50px;height:50px}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQXJlWW91U3VyZS5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBZ0NBLHlCQUFZLENBQ1YsS0FBSyxDQUFFLElBQUksQ0FDWCxNQUFNLENBQUUsSUFDViIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiQXJlWW91U3VyZS5zdmVsdGUiXX0= */");
}
function create_else_block(ctx) {
  let div;
  let span;
  let textContent = "☠️";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-1gvdz8s") span.textContent = textContent;
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "text-2xl");
      add_location(span, file3, 27, 6, 731);
      attr_dev(div, "class", "bg-red-600 flex hover:cursor-pointer justify-center fixed-size svelte-1vqnce");
      add_location(div, file3, 25, 4, 619);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          function() {
            if (is_function(
              /*deleteFn*/
              ctx[0]
            )) ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let span;
  let textContent = "🗑";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      span.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span) !== "svelte-3qd3qz") span.textContent = textContent;
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "text-xs");
      add_location(span, file3, 19, 6, 430);
      attr_dev(div, "class", "flex hover:cursor-pointer justify-center");
      add_location(div, file3, 17, 4, 350);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      if (!mounted) {
        dispose = listen_dev(
          div,
          "click",
          /*fire*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(15:0) {#if trigger == false}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*trigger*/
      ctx2[1] == false
    ) return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AreYouSure", slots, []);
  let { deleteFn } = $$props;
  let { triggerTime = 1e3 } = $$props;
  let trigger = false;
  const fire = () => {
    $$invalidate(1, trigger = true);
    setTimeout(() => $$invalidate(1, trigger = false), triggerTime);
  };
  $$self.$$.on_mount.push(function() {
    if (deleteFn === void 0 && !("deleteFn" in $$props || $$self.$$.bound[$$self.$$.props["deleteFn"]])) {
      console.warn("<AreYouSure> was created without expected prop 'deleteFn'");
    }
  });
  const writable_props = ["deleteFn", "triggerTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<AreYouSure> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("deleteFn" in $$props2) $$invalidate(0, deleteFn = $$props2.deleteFn);
    if ("triggerTime" in $$props2) $$invalidate(3, triggerTime = $$props2.triggerTime);
  };
  $$self.$capture_state = () => ({ deleteFn, triggerTime, trigger, fire });
  $$self.$inject_state = ($$props2) => {
    if ("deleteFn" in $$props2) $$invalidate(0, deleteFn = $$props2.deleteFn);
    if ("triggerTime" in $$props2) $$invalidate(3, triggerTime = $$props2.triggerTime);
    if ("trigger" in $$props2) $$invalidate(1, trigger = $$props2.trigger);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [deleteFn, trigger, fire, triggerTime];
}
var AreYouSure = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { deleteFn: 0, triggerTime: 3 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AreYouSure",
      options,
      id: create_fragment3.name
    });
  }
  get deleteFn() {
    throw new Error("<AreYouSure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteFn(value) {
    throw new Error("<AreYouSure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get triggerTime() {
    throw new Error("<AreYouSure>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set triggerTime(value) {
    throw new Error("<AreYouSure>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AreYouSure_default = AreYouSure;

// node_modules/sveltetools_bils/src/cmp/BtnWIcon.svelte
var { console: console_1 } = globals;
var file4 = "node_modules/sveltetools_bils/src/cmp/BtnWIcon.svelte";
function create_fragment4(ctx) {
  let button;
  let div;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      div = element("div");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = text(" \n    ");
      span1 = element("span");
      t2 = text(
        /*title*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {});
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[0]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_text(div_nodes, " \n    ");
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*title*/
        ctx[3]
      );
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-2xl");
      add_location(span0, file4, 15, 4, 295);
      attr_dev(span1, "class", "text-2xl");
      add_location(span1, file4, 16, 4, 342);
      attr_dev(div, "class", div_class_value = `flex justify-center ${/*bgColor*/
      ctx[2]} 
  text-white rounded-md p-2 m-2 pr-4 
  `);
      add_location(div, file4, 12, 2, 202);
      add_location(button, file4, 10, 0, 175);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx[0]
      );
      if (dirty & /*title*/
      8) set_data_dev(
        t2,
        /*title*/
        ctx[3]
      );
      if (dirty & /*bgColor*/
      4 && div_class_value !== (div_class_value = `flex justify-center ${/*bgColor*/
      ctx[2]} 
  text-white rounded-md p-2 m-2 pr-4 
  `)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BtnWIcon", slots, []);
  let { icon = "📜" } = $$props;
  let { clk = () => console.log("clicked") } = $$props;
  let { bgColor = "bg-blue-800" } = $$props;
  let { title = "The Title" } = $$props;
  const writable_props = ["icon", "clk", "bgColor", "title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_1.warn(`<BtnWIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("clk" in $$props2) $$invalidate(1, clk = $$props2.clk);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("title" in $$props2) $$invalidate(3, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ icon, clk, bgColor, title });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("clk" in $$props2) $$invalidate(1, clk = $$props2.clk);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("title" in $$props2) $$invalidate(3, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, clk, bgColor, title];
}
var BtnWIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { icon: 0, clk: 1, bgColor: 2, title: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BtnWIcon",
      options,
      id: create_fragment4.name
    });
  }
  get icon() {
    throw new Error("<BtnWIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<BtnWIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<BtnWIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<BtnWIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<BtnWIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<BtnWIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<BtnWIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<BtnWIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BtnWIcon_default = BtnWIcon;

// node_modules/sveltetools_bils/src/cmp/BtnWIconSm.svelte
var file5 = "node_modules/sveltetools_bils/src/cmp/BtnWIconSm.svelte";
function create_fragment5(ctx) {
  let button;
  let t0;
  let t1;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = text(" \n");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(
        button_nodes,
        /*icon*/
        ctx[0]
      );
      t1 = claim_text(button_nodes, " \n");
      if (default_slot) default_slot.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = `${/*bgColor*/
      ctx[1]} p-2 m-2 rounded-md px-8 hover:bg-gray-500 active:bg-gray-200`);
      add_location(button, file5, 11, 0, 178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, t1);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx[0]
      );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      2 && button_class_value !== (button_class_value = `${/*bgColor*/
      ctx[1]} p-2 m-2 rounded-md px-8 hover:bg-gray-500 active:bg-gray-200`)) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BtnWIconSm", slots, ["default"]);
  let { icon = "" } = $$props;
  let { bgColor = "bg-blue-800" } = $$props;
  let { clk = () => {
  } } = $$props;
  const writable_props = ["icon", "bgColor", "clk"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BtnWIconSm> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ icon, bgColor, clk });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, clk, $$scope, slots];
}
var BtnWIconSm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { icon: 0, bgColor: 1, clk: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BtnWIconSm",
      options,
      id: create_fragment5.name
    });
  }
  get icon() {
    throw new Error("<BtnWIconSm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<BtnWIconSm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<BtnWIconSm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<BtnWIconSm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<BtnWIconSm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<BtnWIconSm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BtnWIconSm_default = BtnWIconSm;

// node_modules/sveltetools_bils/src/cmp/BtnWIconXs.svelte
var file6 = "node_modules/sveltetools_bils/src/cmp/BtnWIconXs.svelte";
function create_fragment6(ctx) {
  let button;
  let div;
  let t0;
  let t1;
  let button_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      button = element("button");
      div = element("div");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = text(" \n");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      div = claim_element(button_nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(
        div_nodes,
        /*icon*/
        ctx[0]
      );
      t1 = claim_text(div_nodes, " \n");
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "text-xs");
      add_location(div, file6, 14, 0, 286);
      attr_dev(button, "class", button_class_value = `${/*bgColor*/
      ctx[1]} p-1 m-1 rounded-md px-4 hover:bg-gray-500 active:bg-gray-200`);
      add_location(button, file6, 11, 0, 178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx[0]
      );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      2 && button_class_value !== (button_class_value = `${/*bgColor*/
      ctx[1]} p-1 m-1 rounded-md px-4 hover:bg-gray-500 active:bg-gray-200`)) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BtnWIconXs", slots, ["default"]);
  let { icon = "" } = $$props;
  let { bgColor = "bg-blue-800" } = $$props;
  let { clk = () => {
  } } = $$props;
  const writable_props = ["icon", "bgColor", "clk"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BtnWIconXs> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ icon, bgColor, clk });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, clk, $$scope, slots];
}
var BtnWIconXs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { icon: 0, bgColor: 1, clk: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BtnWIconXs",
      options,
      id: create_fragment6.name
    });
  }
  get icon() {
    throw new Error("<BtnWIconXs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<BtnWIconXs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<BtnWIconXs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<BtnWIconXs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<BtnWIconXs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<BtnWIconXs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BtnWIconXs_default = BtnWIconXs;

// node_modules/sveltetools_bils/src/cmp/BtnIconRound.svelte
var { console: console_12 } = globals;
var file7 = "node_modules/sveltetools_bils/src/cmp/BtnIconRound.svelte";
function create_fragment7(ctx) {
  let button;
  let span;
  let t;
  let span_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      span = element("span");
      t = text(
        /*icon*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = `text-2xl`);
      add_location(span, file7, 15, 0, 421);
      attr_dev(button, "class", button_class_value = `${/*bgColor*/
      ctx[1]} ${/*borderColor*/
      ctx[2]} ${/*borderWidth*/
      ctx[3]} inline-block  rounded-md p-1 m-1  hover:bg-gray-900 hover:text-3xl `);
      add_location(button, file7, 13, 0, 277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[4]
            )) ctx[4].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      1) set_data_dev(
        t,
        /*icon*/
        ctx[0]
      );
      if (dirty & /*bgColor, borderColor, borderWidth*/
      14 && button_class_value !== (button_class_value = `${/*bgColor*/
      ctx[1]} ${/*borderColor*/
      ctx[2]} ${/*borderWidth*/
      ctx[3]} inline-block  rounded-md p-1 m-1  hover:bg-gray-900 hover:text-3xl `)) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BtnIconRound", slots, []);
  let { icon = "📜" } = $$props;
  let { bgColor = "bg-gray-700" } = $$props;
  let { borderColor = "border-white" } = $$props;
  let { borderWidth = "border-1" } = $$props;
  let { clk = () => console.log("clicked") } = $$props;
  const writable_props = ["icon", "bgColor", "borderColor", "borderWidth", "clk"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_12.warn(`<BtnIconRound> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("borderColor" in $$props2) $$invalidate(2, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2) $$invalidate(3, borderWidth = $$props2.borderWidth);
    if ("clk" in $$props2) $$invalidate(4, clk = $$props2.clk);
  };
  $$self.$capture_state = () => ({
    icon,
    bgColor,
    borderColor,
    borderWidth,
    clk
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("borderColor" in $$props2) $$invalidate(2, borderColor = $$props2.borderColor);
    if ("borderWidth" in $$props2) $$invalidate(3, borderWidth = $$props2.borderWidth);
    if ("clk" in $$props2) $$invalidate(4, clk = $$props2.clk);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, borderColor, borderWidth, clk];
}
var BtnIconRound = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, {
      icon: 0,
      bgColor: 1,
      borderColor: 2,
      borderWidth: 3,
      clk: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BtnIconRound",
      options,
      id: create_fragment7.name
    });
  }
  get icon() {
    throw new Error("<BtnIconRound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<BtnIconRound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<BtnIconRound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<BtnIconRound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderColor() {
    throw new Error("<BtnIconRound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<BtnIconRound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get borderWidth() {
    throw new Error("<BtnIconRound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderWidth(value) {
    throw new Error("<BtnIconRound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<BtnIconRound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<BtnIconRound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BtnIconRound_default = BtnIconRound;

// node_modules/sveltetools_bils/src/cmp/BtnIconOval.svelte
var { console: console_13 } = globals;
var file8 = "node_modules/sveltetools_bils/src/cmp/BtnIconOval.svelte";
function create_fragment8(ctx) {
  let div;
  let button;
  let span;
  let t;
  let span_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span = element("span");
      t = text(
        /*icon*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span = claim_element(button_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = `${/*textSize*/
      ctx[3]}`);
      add_location(span, file8, 12, 4, 326);
      attr_dev(button, "class", button_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`);
      add_location(button, file8, 8, 2, 194);
      attr_dev(div, "class", "flex justify-center");
      add_location(div, file8, 7, 0, 158);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      1) set_data_dev(
        t,
        /*icon*/
        ctx[0]
      );
      if (dirty & /*textSize*/
      8 && span_class_value !== (span_class_value = `${/*textSize*/
      ctx[3]}`)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*bgColor*/
      2 && button_class_value !== (button_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`)) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BtnIconOval", slots, []);
  let { icon = "⚙️" } = $$props;
  let { bgColor = "bg-gray-700" } = $$props;
  let { clk = () => console.log("clicked") } = $$props;
  let { textSize = "text-md" } = $$props;
  const writable_props = ["icon", "bgColor", "clk", "textSize"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_13.warn(`<BtnIconOval> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
    if ("textSize" in $$props2) $$invalidate(3, textSize = $$props2.textSize);
  };
  $$self.$capture_state = () => ({ icon, bgColor, clk, textSize });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(2, clk = $$props2.clk);
    if ("textSize" in $$props2) $$invalidate(3, textSize = $$props2.textSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, clk, textSize];
}
var BtnIconOval = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { icon: 0, bgColor: 1, clk: 2, textSize: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BtnIconOval",
      options,
      id: create_fragment8.name
    });
  }
  get icon() {
    throw new Error("<BtnIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<BtnIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<BtnIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<BtnIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<BtnIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<BtnIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textSize() {
    throw new Error("<BtnIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textSize(value) {
    throw new Error("<BtnIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BtnIconOval_default = BtnIconOval;

// node_modules/sveltetools_bils/src/cmp/CodeComp.svelte
var file9 = "node_modules/sveltetools_bils/src/cmp/CodeComp.svelte";
function create_fragment9(ctx) {
  let pre;
  let t0;
  let code_1;
  let t1;
  let t2;
  let t3;
  let t4;
  const block = {
    c: function create() {
      pre = element("pre");
      t0 = text("    ");
      code_1 = element("code");
      t1 = text("\n        ");
      t2 = text(
        /*code*/
        ctx[0]
      );
      t3 = text("\n    ");
      t4 = text("\n");
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", {});
      var pre_nodes = children(pre);
      t0 = claim_text(pre_nodes, "    ");
      code_1 = claim_element(pre_nodes, "CODE", { class: true });
      var code_1_nodes = children(code_1);
      t1 = claim_text(code_1_nodes, "\n        ");
      t2 = claim_text(
        code_1_nodes,
        /*code*/
        ctx[0]
      );
      t3 = claim_text(code_1_nodes, "\n    ");
      code_1_nodes.forEach(detach_dev);
      t4 = claim_text(pre_nodes, "\n");
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(code_1, "class", "language-javascript");
      add_location(code_1, file9, 15, 4, 344);
      add_location(pre, file9, 14, 0, 334);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, t0);
      append_hydration_dev(pre, code_1);
      append_hydration_dev(code_1, t1);
      append_hydration_dev(code_1, t2);
      append_hydration_dev(code_1, t3);
      append_hydration_dev(pre, t4);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*code*/
      1) set_data_dev(
        t2,
        /*code*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(pre);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CodeComp", slots, []);
  let { code = "" } = $$props;
  const escapeCode = (str) => {
    let escapedStr = "";
    for (let i = 0; i < str.length; i++) {
      let code2 = str.charCodeAt(i);
      escapedStr += "[u+" + code2.toString(16).padStart(4, "0") + "]";
    }
    return escapedStr;
  };
  const writable_props = ["code"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CodeComp> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("code" in $$props2) $$invalidate(0, code = $$props2.code);
  };
  $$self.$capture_state = () => ({ code, escapeCode });
  $$self.$inject_state = ($$props2) => {
    if ("code" in $$props2) $$invalidate(0, code = $$props2.code);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [code];
}
var CodeComp = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { code: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CodeComp",
      options,
      id: create_fragment9.name
    });
  }
  get code() {
    throw new Error("<CodeComp>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set code(value) {
    throw new Error("<CodeComp>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CodeComp_default = CodeComp;

// node_modules/sveltetools_bils/src/cmp/CardOnly.svelte
var file10 = "node_modules/sveltetools_bils/src/cmp/CardOnly.svelte";
function create_fragment10(ctx) {
  let div4;
  let div3;
  let div0;
  let span;
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*firstXChars*/
    ctx[2](
      /*title*/
      ctx[1]
    ) + ""
  );
  let t2;
  let t3;
  let div2;
  let t4;
  let hr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      if (default_slot) default_slot.c();
      t4 = space();
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (default_slot) default_slot.l(div2_nodes);
      t4 = claim_space(div2_nodes);
      hr = claim_element(div2_nodes, "HR", {});
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "text-4xl");
      add_location(span, file10, 21, 22, 447);
      attr_dev(div0, "class", "mb-2");
      add_location(div0, file10, 21, 4, 429);
      attr_dev(div1, "class", "p-1 m-1 bg-gray-700 text-sm rounded-md");
      add_location(div1, file10, 23, 3, 511);
      add_location(hr, file10, 28, 6, 683);
      attr_dev(div2, "class", "flex justify-center m-0 p-0");
      add_location(div2, file10, 26, 3, 617);
      attr_dev(div3, "class", "flex flex-col");
      add_location(div3, file10, 19, 0, 360);
      attr_dev(div4, "class", "min-w-[150px] bg-gray-600 rounded-md p-2 m-1 border-4 border-blue-700 text-center hover:border-blue-200");
      add_location(div4, file10, 14, 0, 220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration_dev(div2, t4);
      append_hydration_dev(div2, hr);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx2[0]
      );
      if ((!current || dirty & /*title*/
      2) && t2_value !== (t2_value = /*firstXChars*/
      ctx2[2](
        /*title*/
        ctx2[1]
      ) + "")) set_data_dev(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardOnly", slots, ["default"]);
  let { icon = "📜" } = $$props;
  let { title = "The Title" } = $$props;
  let { titleCharsCount = 20 } = $$props;
  function firstXChars(string) {
    return string.slice(0, titleCharsCount);
  }
  const writable_props = ["icon", "title", "titleCharsCount"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CardOnly> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("titleCharsCount" in $$props2) $$invalidate(3, titleCharsCount = $$props2.titleCharsCount);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    titleCharsCount,
    firstXChars
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("titleCharsCount" in $$props2) $$invalidate(3, titleCharsCount = $$props2.titleCharsCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, firstXChars, titleCharsCount, $$scope, slots];
}
var CardOnly = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { icon: 0, title: 1, titleCharsCount: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardOnly",
      options,
      id: create_fragment10.name
    });
  }
  get icon() {
    throw new Error("<CardOnly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<CardOnly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CardOnly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CardOnly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleCharsCount() {
    throw new Error("<CardOnly>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleCharsCount(value) {
    throw new Error("<CardOnly>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardOnly_default = CardOnly;

// node_modules/sveltetools_bils/src/cmp/Card.svelte
var file11 = "node_modules/sveltetools_bils/src/cmp/Card.svelte";
function create_fragment11(ctx) {
  let div4;
  let a;
  let div3;
  let div0;
  let span;
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*firstXChars*/
    ctx[3](
      /*title*/
      ctx[1]
    ) + ""
  );
  let t2;
  let t3;
  let div2;
  let t4;
  let hr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      div4 = element("div");
      a = element("a");
      div3 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      if (default_slot) default_slot.c();
      t4 = space();
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      a = claim_element(div4_nodes, "A", { class: true, href: true, target: true });
      var a_nodes = children(a);
      div3 = claim_element(a_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (default_slot) default_slot.l(div2_nodes);
      t4 = claim_space(div2_nodes);
      hr = claim_element(div2_nodes, "HR", {});
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "text-4xl");
      add_location(span, file11, 24, 22, 552);
      attr_dev(div0, "class", "mb-2");
      add_location(div0, file11, 24, 4, 534);
      attr_dev(div1, "class", "p-1 m-1 bg-gray-700 text-sm rounded-md");
      add_location(div1, file11, 26, 3, 616);
      add_location(hr, file11, 31, 6, 788);
      attr_dev(div2, "class", "flex justify-center m-0 p-0");
      add_location(div2, file11, 29, 3, 722);
      attr_dev(div3, "class", "flex flex-col");
      add_location(div3, file11, 22, 0, 465);
      attr_dev(a, "class", "hover:bg-gray-300 rounded-lg");
      attr_dev(
        a,
        "href",
        /*url*/
        ctx[2]
      );
      attr_dev(a, "target", "");
      add_location(a, file11, 19, 0, 398);
      attr_dev(div4, "class", "min-w-[150px] bg-gray-600 rounded-md p-2 m-1 border-4 border-blue-700 text-center hover:border-blue-200");
      add_location(div4, file11, 15, 0, 259);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, a);
      append_hydration_dev(a, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration_dev(div2, t4);
      append_hydration_dev(div2, hr);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx2[0]
      );
      if ((!current || dirty & /*title*/
      2) && t2_value !== (t2_value = /*firstXChars*/
      ctx2[3](
        /*title*/
        ctx2[1]
      ) + "")) set_data_dev(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*url*/
      4) {
        attr_dev(
          a,
          "href",
          /*url*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Card", slots, ["default"]);
  let { icon = "📜" } = $$props;
  let { title = "The Title" } = $$props;
  let { url = "https://google.com" } = $$props;
  let { titleCharsCount = 20 } = $$props;
  function firstXChars(string) {
    return string.slice(0, titleCharsCount);
  }
  const writable_props = ["icon", "title", "url", "titleCharsCount"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Card> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(2, url = $$props2.url);
    if ("titleCharsCount" in $$props2) $$invalidate(4, titleCharsCount = $$props2.titleCharsCount);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    url,
    titleCharsCount,
    firstXChars
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(2, url = $$props2.url);
    if ("titleCharsCount" in $$props2) $$invalidate(4, titleCharsCount = $$props2.titleCharsCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, url, firstXChars, titleCharsCount, $$scope, slots];
}
var Card = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, {
      icon: 0,
      title: 1,
      url: 2,
      titleCharsCount: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Card",
      options,
      id: create_fragment11.name
    });
  }
  get icon() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleCharsCount() {
    throw new Error("<Card>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleCharsCount(value) {
    throw new Error("<Card>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Card_default = Card;

// node_modules/sveltetools_bils/src/cmp/CardImg.svelte
var file12 = "node_modules/sveltetools_bils/src/cmp/CardImg.svelte";
function create_fragment12(ctx) {
  let div4;
  let a;
  let div3;
  let div0;
  let img_1;
  let img_1_src_value;
  let t0;
  let div1;
  let t1_value = (
    /*firstXChars*/
    ctx[4](
      /*title*/
      ctx[2]
    ) + ""
  );
  let t1;
  let t2;
  let div2;
  let t3;
  let hr;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div4 = element("div");
      a = element("a");
      div3 = element("div");
      div0 = element("div");
      img_1 = element("img");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      div2 = element("div");
      if (default_slot) default_slot.c();
      t3 = space();
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      a = claim_element(div4_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      div3 = claim_element(a_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      img_1 = claim_element(div0_nodes, "IMG", {
        class: true,
        width: true,
        height: true,
        src: true,
        alt: true
      });
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, t1_value);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (default_slot) default_slot.l(div2_nodes);
      t3 = claim_space(div2_nodes);
      hr = claim_element(div2_nodes, "HR", {});
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img_1, "class", "mb-2");
      attr_dev(img_1, "width", "200");
      attr_dev(img_1, "height", "300");
      if (!src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx[0])) attr_dev(img_1, "src", img_1_src_value);
      attr_dev(
        img_1,
        "alt",
        /*alt*/
        ctx[1]
      );
      add_location(img_1, file12, 26, 4, 595);
      attr_dev(div0, "class", "flex justify-center");
      add_location(div0, file12, 25, 4, 557);
      attr_dev(div1, "class", "p-1 m-1 bg-gray-700 text-sm rounded-md");
      add_location(div1, file12, 29, 3, 689);
      add_location(hr, file12, 34, 6, 861);
      attr_dev(div2, "class", "flex justify-center m-0 p-0");
      add_location(div2, file12, 32, 3, 795);
      attr_dev(div3, "class", "flex flex-col");
      add_location(div3, file12, 23, 0, 488);
      attr_dev(a, "class", "hover:bg-stone-600 rounded-lg");
      attr_dev(
        a,
        "href",
        /*url*/
        ctx[3]
      );
      add_location(a, file12, 20, 0, 429);
      attr_dev(div4, "class", "min-w-[150px] bg-gray-600 rounded-md p-2 m-1 border-4 border-blue-700 text-center hover:border-blue-200");
      add_location(div4, file12, 16, 0, 290);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, a);
      append_hydration_dev(a, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, img_1);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, hr);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*img*/
      1 && !src_url_equal(img_1.src, img_1_src_value = /*img*/
      ctx2[0])) {
        attr_dev(img_1, "src", img_1_src_value);
      }
      if (!current || dirty & /*alt*/
      2) {
        attr_dev(
          img_1,
          "alt",
          /*alt*/
          ctx2[1]
        );
      }
      if ((!current || dirty & /*title*/
      4) && t1_value !== (t1_value = /*firstXChars*/
      ctx2[4](
        /*title*/
        ctx2[2]
      ) + "")) set_data_dev(t1, t1_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*url*/
      8) {
        attr_dev(
          a,
          "href",
          /*url*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardImg", slots, ["default"]);
  let { img = "" } = $$props;
  let { alt = "Image not found" } = $$props;
  let { title = "The Title" } = $$props;
  let { url = "https://google.com" } = $$props;
  let { titleCharsCount = 25 } = $$props;
  function firstXChars(string) {
    return string.slice(0, titleCharsCount);
  }
  const writable_props = ["img", "alt", "title", "url", "titleCharsCount"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CardImg> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("img" in $$props2) $$invalidate(0, img = $$props2.img);
    if ("alt" in $$props2) $$invalidate(1, alt = $$props2.alt);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(3, url = $$props2.url);
    if ("titleCharsCount" in $$props2) $$invalidate(5, titleCharsCount = $$props2.titleCharsCount);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    img,
    alt,
    title,
    url,
    titleCharsCount,
    firstXChars
  });
  $$self.$inject_state = ($$props2) => {
    if ("img" in $$props2) $$invalidate(0, img = $$props2.img);
    if ("alt" in $$props2) $$invalidate(1, alt = $$props2.alt);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(3, url = $$props2.url);
    if ("titleCharsCount" in $$props2) $$invalidate(5, titleCharsCount = $$props2.titleCharsCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [img, alt, title, url, firstXChars, titleCharsCount, $$scope, slots];
}
var CardImg = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      img: 0,
      alt: 1,
      title: 2,
      url: 3,
      titleCharsCount: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardImg",
      options,
      id: create_fragment12.name
    });
  }
  get img() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set img(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleCharsCount() {
    throw new Error("<CardImg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleCharsCount(value) {
    throw new Error("<CardImg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardImg_default = CardImg;

// node_modules/sveltetools_bils/src/cmp/CardBtn.svelte
var file13 = "node_modules/sveltetools_bils/src/cmp/CardBtn.svelte";
function create_fragment13(ctx) {
  let div4;
  let button;
  let div3;
  let div0;
  let span;
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*firstXChars*/
    ctx[4](
      /*title*/
      ctx[1]
    ) + ""
  );
  let t2;
  let t3;
  let div2;
  let t4;
  let hr;
  let div4_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div4 = element("div");
      button = element("button");
      div3 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      div2 = element("div");
      if (default_slot) default_slot.c();
      t4 = space();
      hr = element("hr");
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      button = claim_element(div4_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      div3 = claim_element(button_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t0 = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (default_slot) default_slot.l(div2_nodes);
      t4 = claim_space(div2_nodes);
      hr = claim_element(div2_nodes, "HR", {});
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "text-4xl");
      add_location(span, file13, 25, 22, 563);
      attr_dev(div0, "class", "mb-2");
      add_location(div0, file13, 25, 4, 545);
      attr_dev(div1, "class", "p-1 m-1 bg-gray-700 text-sm rounded-md");
      add_location(div1, file13, 27, 3, 627);
      add_location(hr, file13, 32, 6, 799);
      attr_dev(div2, "class", "flex justify-center m-0 p-0");
      add_location(div2, file13, 30, 3, 733);
      attr_dev(div3, "class", "flex flex-col");
      add_location(div3, file13, 23, 0, 475);
      attr_dev(button, "class", "rounded-lg");
      add_location(button, file13, 20, 0, 425);
      attr_dev(div4, "class", div4_class_value = `min-w-[150px]  ${/*bgColor*/
      ctx[2]} rounded-md p-2 m-1 
border-4  border-blue-700 text-center 
hover:border-green-500`);
      add_location(div4, file13, 16, 0, 282);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, button);
      append_hydration_dev(button, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append_hydration_dev(div2, t4);
      append_hydration_dev(div2, hr);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[3]
            )) ctx[3].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx[0]
      );
      if ((!current || dirty & /*title*/
      2) && t2_value !== (t2_value = /*firstXChars*/
      ctx[4](
        /*title*/
        ctx[1]
      ) + "")) set_data_dev(t2, t2_value);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      4 && div4_class_value !== (div4_class_value = `min-w-[150px]  ${/*bgColor*/
      ctx[2]} rounded-md p-2 m-1 
border-4  border-blue-700 text-center 
hover:border-green-500`)) {
        attr_dev(div4, "class", div4_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CardBtn", slots, ["default"]);
  let { icon = "📜" } = $$props;
  let { title = "The Title" } = $$props;
  let { bgColor = "bg-gray-600" } = $$props;
  let { clk = () => true } = $$props;
  let { titleCharsCount = 20 } = $$props;
  function firstXChars(string) {
    return string.slice(0, titleCharsCount);
  }
  const writable_props = ["icon", "title", "bgColor", "clk", "titleCharsCount"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CardBtn> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("titleCharsCount" in $$props2) $$invalidate(5, titleCharsCount = $$props2.titleCharsCount);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    bgColor,
    clk,
    titleCharsCount,
    firstXChars
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("bgColor" in $$props2) $$invalidate(2, bgColor = $$props2.bgColor);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("titleCharsCount" in $$props2) $$invalidate(5, titleCharsCount = $$props2.titleCharsCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, bgColor, clk, firstXChars, titleCharsCount, $$scope, slots];
}
var CardBtn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {
      icon: 0,
      title: 1,
      bgColor: 2,
      clk: 3,
      titleCharsCount: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CardBtn",
      options,
      id: create_fragment13.name
    });
  }
  get icon() {
    throw new Error("<CardBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<CardBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<CardBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<CardBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<CardBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<CardBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<CardBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<CardBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get titleCharsCount() {
    throw new Error("<CardBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set titleCharsCount(value) {
    throw new Error("<CardBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CardBtn_default = CardBtn;

// node_modules/sveltetools_bils/src/cmp/Centre.svelte
var file14 = "node_modules/sveltetools_bils/src/cmp/Centre.svelte";
function create_fragment14(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "flex justify-center");
      add_location(div, file14, 5, 0, 5);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Centre", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Centre> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Centre = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Centre",
      options,
      id: create_fragment14.name
    });
  }
};
var Centre_default = Centre;

// node_modules/sveltetools_bils/src/cmp/Comment.svelte
var file15 = "node_modules/sveltetools_bils/src/cmp/Comment.svelte";
function create_fragment15(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `m-1 p-2 rounded-md ${/*bgColor*/
      ctx[1]}  ${/*textColor*/
      ctx[0]} text-xs`);
      add_location(div, file15, 7, 0, 111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor, textColor*/
      3 && div_class_value !== (div_class_value = `m-1 p-2 rounded-md ${/*bgColor*/
      ctx2[1]}  ${/*textColor*/
      ctx2[0]} text-xs`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Comment", slots, ["default"]);
  let { textColor = "text-yellow-400" } = $$props;
  let { bgColor = "bg-gray-900" } = $$props;
  const writable_props = ["textColor", "bgColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Comment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("textColor" in $$props2) $$invalidate(0, textColor = $$props2.textColor);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ textColor, bgColor });
  $$self.$inject_state = ($$props2) => {
    if ("textColor" in $$props2) $$invalidate(0, textColor = $$props2.textColor);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [textColor, bgColor, $$scope, slots];
}
var Comment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { textColor: 0, bgColor: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Comment",
      options,
      id: create_fragment15.name
    });
  }
  get textColor() {
    throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textColor(value) {
    throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Comment_default = Comment;

// node_modules/sveltetools_bils/src/cmp/DDDivs.svelte
var file16 = "node_modules/sveltetools_bils/src/cmp/DDDivs.svelte";
var get_item2_slot_changes = (dirty) => ({});
var get_item2_slot_context = (ctx) => ({});
var get_item1_slot_changes = (dirty) => ({});
var get_item1_slot_context = (ctx) => ({});
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let option;
  let t_value = (
    /*item*/
    ctx[5] + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", { class: true });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(option, "class", "border-b-1 border-white");
      option.__value = option_value_value = /*item*/
      ctx[5];
      set_input_value(option, option.__value);
      add_location(option, file16, 13, 12, 411);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*items*/
      1 && t_value !== (t_value = /*item*/
      ctx2[5] + "")) set_data_dev(t, t_value);
      if (dirty & /*items*/
      1 && option_value_value !== (option_value_value = /*item*/
      ctx2[5])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(13:8) {#each items as item}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let current;
  const item2_slot_template = (
    /*#slots*/
    ctx[3].item2
  );
  const item2_slot = create_slot(
    item2_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_item2_slot_context
  );
  const block = {
    c: function create() {
      if (item2_slot) item2_slot.c();
    },
    l: function claim(nodes) {
      if (item2_slot) item2_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (item2_slot) {
        item2_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (item2_slot) {
        if (item2_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            item2_slot,
            item2_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              item2_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_item2_slot_changes
            ),
            get_item2_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item2_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item2_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (item2_slot) item2_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(23:36) ",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let current;
  const item1_slot_template = (
    /*#slots*/
    ctx[3].item1
  );
  const item1_slot = create_slot(
    item1_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    get_item1_slot_context
  );
  const block = {
    c: function create() {
      if (item1_slot) item1_slot.c();
    },
    l: function claim(nodes) {
      if (item1_slot) item1_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (item1_slot) {
        item1_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (item1_slot) {
        if (item1_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            item1_slot,
            item1_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              item1_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              get_item1_slot_changes
            ),
            get_item1_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item1_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item1_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (item1_slot) item1_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(21:4) {#if selected === items[0]}",
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let div1;
  let br0;
  let t0;
  let div0;
  let select;
  let t1;
  let br1;
  let t2;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const if_block_creators = [create_if_block2, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*selected*/
      ctx2[1] === /*items*/
      ctx2[0][0]
    ) return 0;
    if (
      /*selected*/
      ctx2[1] === /*items*/
      ctx2[0][1]
    ) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      br0 = element("br");
      t0 = space();
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      br1 = element("br");
      t2 = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      br0 = claim_element(div1_nodes, "BR", {});
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", { type: true, class: true });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      br1 = claim_element(div1_nodes, "BR", {});
      t2 = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(br0, file16, 9, 4, 213);
      attr_dev(select, "type", "datetime-local");
      attr_dev(select, "class", "bg-gray-800 w-full text-center");
      if (
        /*selected*/
        ctx[1] === void 0
      ) add_render_callback(() => (
        /*select_change_handler*/
        ctx[4].call(select)
      ));
      add_location(select, file16, 11, 8, 276);
      attr_dev(div0, "class", "mx-10 border-2 border-gray-500");
      add_location(div0, file16, 10, 4, 223);
      add_location(br1, file16, 17, 4, 516);
      attr_dev(div1, "class", "m-1 border-2 border-gray-500");
      add_location(div1, file16, 7, 0, 165);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, br0);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*selected*/
        ctx[1],
        true
      );
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, br1);
      append_hydration_dev(div1, t2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          select,
          "change",
          /*select_change_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*items*/
      1) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*selected, items*/
      3) {
        select_option(
          select,
          /*selected*/
          ctx2[1]
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(div1, null);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DDDivs", slots, ["item1", "item2"]);
  let { items } = $$props;
  let selected = items[0];
  $$self.$$.on_mount.push(function() {
    if (items === void 0 && !("items" in $$props || $$self.$$.bound[$$self.$$.props["items"]])) {
      console.warn("<DDDivs> was created without expected prop 'items'");
    }
  });
  const writable_props = ["items"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DDDivs> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    selected = select_value(this);
    $$invalidate(1, selected);
    $$invalidate(0, items);
  }
  $$self.$$set = ($$props2) => {
    if ("items" in $$props2) $$invalidate(0, items = $$props2.items);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ items, selected });
  $$self.$inject_state = ($$props2) => {
    if ("items" in $$props2) $$invalidate(0, items = $$props2.items);
    if ("selected" in $$props2) $$invalidate(1, selected = $$props2.selected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [items, selected, $$scope, slots, select_change_handler];
}
var DDDivs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { items: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DDDivs",
      options,
      id: create_fragment16.name
    });
  }
  get items() {
    throw new Error("<DDDivs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set items(value) {
    throw new Error("<DDDivs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DDDivs_default = DDDivs;

// node_modules/sveltetools_bils/src/cmp/Footer.svelte
var file17 = "node_modules/sveltetools_bils/src/cmp/Footer.svelte";
function create_fragment17(ctx) {
  let br0;
  let t0;
  let br1;
  let t1;
  let br2;
  let t2;
  let footer;
  let div1;
  let div0;
  let span;
  let a;
  let t3;
  const block = {
    c: function create() {
      br0 = element("br");
      t0 = space();
      br1 = element("br");
      t1 = space();
      br2 = element("br");
      t2 = space();
      footer = element("footer");
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      a = element("a");
      t3 = text(
        /*title*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      br0 = claim_element(nodes, "BR", {});
      t0 = claim_space(nodes);
      br1 = claim_element(nodes, "BR", {});
      t1 = claim_space(nodes);
      br2 = claim_element(nodes, "BR", {});
      t2 = claim_space(nodes);
      footer = claim_element(nodes, "FOOTER", { class: true });
      var footer_nodes = children(footer);
      div1 = claim_element(footer_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", {});
      var span_nodes = children(span);
      a = claim_element(span_nodes, "A", { href: true, class: true });
      var a_nodes = children(a);
      t3 = claim_text(
        a_nodes,
        /*title*/
        ctx[0]
      );
      a_nodes.forEach(detach_dev);
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      footer_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(br0, file17, 5, 0, 96);
      add_location(br1, file17, 6, 0, 102);
      add_location(br2, file17, 7, 0, 108);
      attr_dev(
        a,
        "href",
        /*url*/
        ctx[1]
      );
      attr_dev(a, "class", "text-2xl");
      add_location(a, file17, 11, 10, 272);
      add_location(span, file17, 11, 4, 266);
      attr_dev(div0, "class", "flex flex-wrap justify-between items-center");
      add_location(div0, file17, 10, 4, 204);
      attr_dev(div1, "class", "container mx-auto py-2");
      add_location(div1, file17, 9, 2, 163);
      attr_dev(footer, "class", "bg-gray-900 p-2 text-gray-500");
      add_location(footer, file17, 8, 0, 114);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, br0, anchor);
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, br1, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, br2, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, footer, anchor);
      append_hydration_dev(footer, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, a);
      append_hydration_dev(a, t3);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      1) set_data_dev(
        t3,
        /*title*/
        ctx2[0]
      );
      if (dirty & /*url*/
      2) {
        attr_dev(
          a,
          "href",
          /*url*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(br0);
        detach_dev(t0);
        detach_dev(br1);
        detach_dev(t1);
        detach_dev(br2);
        detach_dev(t2);
        detach_dev(footer);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Footer", slots, []);
  let { title = "skillzaa.com" } = $$props;
  let { url = "https://skillzaa.com" } = $$props;
  const writable_props = ["title", "url"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Footer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(1, url = $$props2.url);
  };
  $$self.$capture_state = () => ({ title, url });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("url" in $$props2) $$invalidate(1, url = $$props2.url);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, url];
}
var Footer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { title: 0, url: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Footer",
      options,
      id: create_fragment17.name
    });
  }
  get title() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Footer_default = Footer;

// node_modules/sveltetools_bils/src/cmp/FormRow.svelte
var file18 = "node_modules/sveltetools_bils/src/cmp/FormRow.svelte";
function create_fragment18(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*title*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "flex justify-center items-center w-1/3 p-1 pl-5 pr-5 m-1 bg-gray-800 border-gray-500 border-2");
      add_location(div0, file18, 9, 2, 73);
      attr_dev(div1, "class", "w-full p-1 pl-5 pr-5 m-1 bg-gray-800 border-gray-500 border-2");
      add_location(div1, file18, 10, 2, 199);
      attr_dev(div2, "class", "flex");
      add_location(div2, file18, 8, 0, 52);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      1) set_data_dev(
        t0,
        /*title*/
        ctx2[0]
      );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormRow", slots, ["default"]);
  let { title = "Title" } = $$props;
  const writable_props = ["title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<FormRow> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ title });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, $$scope, slots];
}
var FormRow = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { title: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormRow",
      options,
      id: create_fragment18.name
    });
  }
  get title() {
    throw new Error("<FormRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<FormRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormRow_default = FormRow;

// node_modules/sveltetools_bils/src/cmp/FormElm.svelte
var file19 = "node_modules/sveltetools_bils/src/cmp/FormElm.svelte";
function create_fragment19(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `w-full border-2 ${/*borderColor*/
      ctx[0]} rounded-md`);
      add_location(div, file19, 7, 0, 64);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*borderColor*/
      1 && div_class_value !== (div_class_value = `w-full border-2 ${/*borderColor*/
      ctx2[0]} rounded-md`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FormElm", slots, ["default"]);
  let { borderColor = "border-white" } = $$props;
  const writable_props = ["borderColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<FormElm> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("borderColor" in $$props2) $$invalidate(0, borderColor = $$props2.borderColor);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ borderColor });
  $$self.$inject_state = ($$props2) => {
    if ("borderColor" in $$props2) $$invalidate(0, borderColor = $$props2.borderColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [borderColor, $$scope, slots];
}
var FormElm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { borderColor: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FormElm",
      options,
      id: create_fragment19.name
    });
  }
  get borderColor() {
    throw new Error("<FormElm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set borderColor(value) {
    throw new Error("<FormElm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FormElm_default = FormElm;

// node_modules/sveltetools_bils/src/cmp/HdgWithIcon.svelte
var file20 = "node_modules/sveltetools_bils/src/cmp/HdgWithIcon.svelte";
function create_fragment20(ctx) {
  let div;
  let span0;
  let t0;
  let span0_class_value;
  let t1;
  let span1;
  let span1_class_value;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = text(" \n    ");
      span1 = element("span");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[0]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_text(div_nodes, " \n    ");
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      if (default_slot) default_slot.l(span1_nodes);
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = `text-${/*size*/
      ctx[2]}xl`);
      add_location(span0, file20, 9, 4, 221);
      attr_dev(span1, "class", span1_class_value = `text-${/*size*/
      ctx[2]}xl`);
      add_location(span1, file20, 10, 4, 276);
      attr_dev(div, "class", div_class_value = `inline-flex  justify-center ${/*bgColor*/
      ctx[1]} text-white rounded-md p-2  px-8 m-2`);
      add_location(div, file20, 8, 2, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span1);
      if (default_slot) {
        default_slot.m(span1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx2[0]
      );
      if (!current || dirty & /*size*/
      4 && span0_class_value !== (span0_class_value = `text-${/*size*/
      ctx2[2]}xl`)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*size*/
      4 && span1_class_value !== (span1_class_value = `text-${/*size*/
      ctx2[2]}xl`)) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (!current || dirty & /*bgColor*/
      2 && div_class_value !== (div_class_value = `inline-flex  justify-center ${/*bgColor*/
      ctx2[1]} text-white rounded-md p-2  px-8 m-2`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HdgWithIcon", slots, ["default"]);
  let { icon = "📜" } = $$props;
  let { bgColor = "bg-blue-800" } = $$props;
  let { size = 2 } = $$props;
  const writable_props = ["icon", "bgColor", "size"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<HdgWithIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("size" in $$props2) $$invalidate(2, size = $$props2.size);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ icon, bgColor, size });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("size" in $$props2) $$invalidate(2, size = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, size, $$scope, slots];
}
var HdgWithIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { icon: 0, bgColor: 1, size: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HdgWithIcon",
      options,
      id: create_fragment20.name
    });
  }
  get icon() {
    throw new Error("<HdgWithIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<HdgWithIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<HdgWithIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<HdgWithIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<HdgWithIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<HdgWithIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HdgWithIcon_default = HdgWithIcon;

// node_modules/sveltetools_bils/src/cmp/Img.svelte
var file21 = "node_modules/sveltetools_bils/src/cmp/Img.svelte";
function create_fragment21(ctx) {
  let div;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      img = claim_element(div_nodes, "IMG", { src: true, alt: true });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*url*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(
        img,
        "alt",
        /*alt*/
        ctx[1]
      );
      add_location(img, file21, 6, 0, 134);
      attr_dev(div, "class", "flex justify-center w-full");
      add_location(div, file21, 5, 0, 93);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, img);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*url*/
      1 && !src_url_equal(img.src, img_src_value = /*url*/
      ctx2[0])) {
        attr_dev(img, "src", img_src_value);
      }
      if (dirty & /*alt*/
      2) {
        attr_dev(
          img,
          "alt",
          /*alt*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Img", slots, []);
  let { url = "/images/HdgWithIcon.png" } = $$props;
  let { alt = "Alt Text" } = $$props;
  const writable_props = ["url", "alt"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Img> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("alt" in $$props2) $$invalidate(1, alt = $$props2.alt);
  };
  $$self.$capture_state = () => ({ url, alt });
  $$self.$inject_state = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("alt" in $$props2) $$invalidate(1, alt = $$props2.alt);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [url, alt];
}
var Img = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { url: 0, alt: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Img",
      options,
      id: create_fragment21.name
    });
  }
  get url() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get alt() {
    throw new Error("<Img>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set alt(value) {
    throw new Error("<Img>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Img_default = Img;

// node_modules/sveltetools_bils/src/cmp/InputForm.svelte
var file22 = "node_modules/sveltetools_bils/src/cmp/InputForm.svelte";
function create_if_block3(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*comment*/
        ctx[5]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*comment*/
        ctx[5]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `m-1 p-2 rounded-md text-yellow-300   bg-gray=900 text-xs`);
      add_location(div, file22, 20, 0, 605);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*comment*/
      32) set_data_dev(
        t,
        /*comment*/
        ctx2[5]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(20:1) {#if comment !== ''}",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div2;
  let div1;
  let h1;
  let t0;
  let t1;
  let input;
  let t2;
  let t3;
  let div0;
  let button;
  let span1;
  let t4;
  let span0;
  let t5;
  let button_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*comment*/
    ctx[5] !== "" && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[1]
      );
      t1 = space();
      input = element("input");
      t2 = space();
      if (if_block) if_block.c();
      t3 = space();
      div0 = element("div");
      button = element("button");
      span1 = element("span");
      t4 = text(
        /*icon*/
        ctx[4]
      );
      span0 = element("span");
      t5 = text(
        /*btnTitle*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      h1 = claim_element(div1_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[1]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", { class: true, type: true });
      t2 = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button = claim_element(div0_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t4 = claim_text(
        span1_nodes,
        /*icon*/
        ctx[4]
      );
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t5 = claim_text(
        span0_nodes,
        /*btnTitle*/
        ctx[2]
      );
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "m-1 text-slate-200 text-2xl underline");
      add_location(h1, file22, 16, 4, 412);
      attr_dev(input, "class", "bg-gray-700 text-white w-10/12 m-1 rounded-lg p-2");
      attr_dev(input, "type", "text");
      add_location(input, file22, 17, 4, 479);
      attr_dev(span0, "class", "hidden md:inline text-sm");
      add_location(span0, file22, 31, 31, 976);
      attr_dev(span1, "class", "text-2xl");
      add_location(span1, file22, 31, 2, 947);
      attr_dev(button, "class", button_class_value = ` ${/*btnColor*/
      ctx[3]}  hover:bg-green-600  active:bg-green-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `);
      add_location(button, file22, 27, 2, 770);
      attr_dev(div0, "class", "flex flex-col sm:flex-row justify-center w-full");
      add_location(div0, file22, 25, 0, 705);
      attr_dev(div1, "class", "border-2 border-white p-2 m-2 text-center rounded-lg ");
      add_location(div1, file22, 15, 0, 338);
      attr_dev(div2, "class", "bg-gray-800 text-white m-0 py-0 px-6");
      add_location(div2, file22, 12, 0, 285);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, input);
      set_input_value(
        input,
        /*newTitle*/
        ctx[6]
      );
      append_hydration_dev(div1, t2);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t4);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t5);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen_dev(
            button,
            "click",
            /*click_handler*/
            ctx[8],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      2) set_data_dev(
        t0,
        /*title*/
        ctx2[1]
      );
      if (dirty & /*newTitle*/
      64 && input.value !== /*newTitle*/
      ctx2[6]) {
        set_input_value(
          input,
          /*newTitle*/
          ctx2[6]
        );
      }
      if (
        /*comment*/
        ctx2[5] !== ""
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div1, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*icon*/
      16) set_data_dev(
        t4,
        /*icon*/
        ctx2[4]
      );
      if (dirty & /*btnTitle*/
      4) set_data_dev(
        t5,
        /*btnTitle*/
        ctx2[2]
      );
      if (dirty & /*btnColor*/
      8 && button_class_value !== (button_class_value = ` ${/*btnColor*/
      ctx2[3]}  hover:bg-green-600  active:bg-green-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `)) {
        attr_dev(button, "class", button_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputForm", slots, []);
  let newTitle = "";
  let { clk = () => true } = $$props;
  let { title = "Create New" } = $$props;
  let { btnTitle = "New" } = $$props;
  let { btnColor = "bg-green-800" } = $$props;
  let { icon = "📝" } = $$props;
  let { comment = "" } = $$props;
  const writable_props = ["clk", "title", "btnTitle", "btnColor", "icon", "comment"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<InputForm> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    newTitle = this.value;
    $$invalidate(6, newTitle);
  }
  const click_handler = () => clk(newTitle);
  $$self.$$set = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("btnTitle" in $$props2) $$invalidate(2, btnTitle = $$props2.btnTitle);
    if ("btnColor" in $$props2) $$invalidate(3, btnColor = $$props2.btnColor);
    if ("icon" in $$props2) $$invalidate(4, icon = $$props2.icon);
    if ("comment" in $$props2) $$invalidate(5, comment = $$props2.comment);
  };
  $$self.$capture_state = () => ({
    newTitle,
    clk,
    title,
    btnTitle,
    btnColor,
    icon,
    comment
  });
  $$self.$inject_state = ($$props2) => {
    if ("newTitle" in $$props2) $$invalidate(6, newTitle = $$props2.newTitle);
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("btnTitle" in $$props2) $$invalidate(2, btnTitle = $$props2.btnTitle);
    if ("btnColor" in $$props2) $$invalidate(3, btnColor = $$props2.btnColor);
    if ("icon" in $$props2) $$invalidate(4, icon = $$props2.icon);
    if ("comment" in $$props2) $$invalidate(5, comment = $$props2.comment);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    clk,
    title,
    btnTitle,
    btnColor,
    icon,
    comment,
    newTitle,
    input_input_handler,
    click_handler
  ];
}
var InputForm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, {
      clk: 0,
      title: 1,
      btnTitle: 2,
      btnColor: 3,
      icon: 4,
      comment: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputForm",
      options,
      id: create_fragment22.name
    });
  }
  get clk() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnTitle() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnTitle(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnColor() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnColor(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comment() {
    throw new Error("<InputForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comment(value) {
    throw new Error("<InputForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputForm_default = InputForm;

// node_modules/sveltetools_bils/src/cmp/InputFormCancel.svelte
var file23 = "node_modules/sveltetools_bils/src/cmp/InputFormCancel.svelte";
function create_if_block4(ctx) {
  let div;
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(
        /*comment*/
        ctx[9]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(
        div_nodes,
        /*comment*/
        ctx[9]
      );
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `m-1 p-2 rounded-md text-yellow-300   bg-gray=900 text-xs`);
      add_location(div, file23, 24, 0, 725);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*comment*/
      512) set_data_dev(
        t,
        /*comment*/
        ctx2[9]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(24:1) {#if comment !== ''}",
    ctx
  });
  return block;
}
function create_fragment23(ctx) {
  let div2;
  let div1;
  let h1;
  let t0;
  let t1;
  let input;
  let t2;
  let t3;
  let div0;
  let button0;
  let span1;
  let t4;
  let span0;
  let t5;
  let button0_class_value;
  let t6;
  let button1;
  let span3;
  let t7;
  let span2;
  let t8;
  let button1_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*comment*/
    ctx[9] !== "" && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[2]
      );
      t1 = space();
      input = element("input");
      t2 = space();
      if (if_block) if_block.c();
      t3 = space();
      div0 = element("div");
      button0 = element("button");
      span1 = element("span");
      t4 = text(
        /*icon*/
        ctx[7]
      );
      span0 = element("span");
      t5 = text(
        /*btnTitle*/
        ctx[3]
      );
      t6 = space();
      button1 = element("button");
      span3 = element("span");
      t7 = text(
        /*icon2*/
        ctx[8]
      );
      span2 = element("span");
      t8 = text(
        /*btn2Title*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      h1 = claim_element(div1_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[2]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      input = claim_element(div1_nodes, "INPUT", { class: true, type: true });
      t2 = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      span1 = claim_element(button0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t4 = claim_text(
        span1_nodes,
        /*icon*/
        ctx[7]
      );
      span0 = claim_element(span1_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t5 = claim_text(
        span0_nodes,
        /*btnTitle*/
        ctx[3]
      );
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      button0_nodes.forEach(detach_dev);
      t6 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      span3 = claim_element(button1_nodes, "SPAN", { class: true });
      var span3_nodes = children(span3);
      t7 = claim_text(
        span3_nodes,
        /*icon2*/
        ctx[8]
      );
      span2 = claim_element(span3_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      t8 = claim_text(
        span2_nodes,
        /*btn2Title*/
        ctx[4]
      );
      span2_nodes.forEach(detach_dev);
      span3_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "m-1 text-slate-200 text-2xl underline");
      add_location(h1, file23, 20, 4, 532);
      attr_dev(input, "class", "bg-gray-700 text-white w-10/12 m-1 rounded-lg p-2");
      attr_dev(input, "type", "text");
      add_location(input, file23, 21, 4, 599);
      attr_dev(span0, "class", "hidden md:inline text-sm");
      add_location(span0, file23, 34, 30, 1093);
      attr_dev(span1, "class", "text-2xl");
      add_location(span1, file23, 34, 1, 1064);
      attr_dev(button0, "class", button0_class_value = ` ${/*btnColor*/
      ctx[5]}  hover:bg-green-600  active:bg-green-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `);
      add_location(button0, file23, 31, 2, 890);
      attr_dev(span2, "class", "hidden md:inline text-sm");
      add_location(span2, file23, 43, 31, 1404);
      attr_dev(span3, "class", "text-2xl");
      add_location(span3, file23, 43, 1, 1374);
      attr_dev(button1, "class", button1_class_value = ` ${/*btn2Color*/
      ctx[6]}  hover:bg-gray-400  active:bg-gray-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `);
      add_location(button1, file23, 40, 2, 1200);
      attr_dev(div0, "class", "flex flex-col sm:flex-row justify-center w-full");
      add_location(div0, file23, 29, 0, 825);
      attr_dev(div1, "class", "border-2 border-white p-2 m-2 text-center rounded-lg ");
      add_location(div1, file23, 19, 0, 458);
      attr_dev(div2, "class", "bg-gray-800 text-white m-0 py-0 px-6");
      add_location(div2, file23, 16, 0, 405);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, input);
      set_input_value(
        input,
        /*newTitle*/
        ctx[10]
      );
      append_hydration_dev(div1, t2);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      append_hydration_dev(button0, span1);
      append_hydration_dev(span1, t4);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t5);
      append_hydration_dev(div0, t6);
      append_hydration_dev(div0, button1);
      append_hydration_dev(button1, span3);
      append_hydration_dev(span3, t7);
      append_hydration_dev(span3, span2);
      append_hydration_dev(span2, t8);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[11]
          ),
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[13],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      4) set_data_dev(
        t0,
        /*title*/
        ctx2[2]
      );
      if (dirty & /*newTitle*/
      1024 && input.value !== /*newTitle*/
      ctx2[10]) {
        set_input_value(
          input,
          /*newTitle*/
          ctx2[10]
        );
      }
      if (
        /*comment*/
        ctx2[9] !== ""
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(div1, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*icon*/
      128) set_data_dev(
        t4,
        /*icon*/
        ctx2[7]
      );
      if (dirty & /*btnTitle*/
      8) set_data_dev(
        t5,
        /*btnTitle*/
        ctx2[3]
      );
      if (dirty & /*btnColor*/
      32 && button0_class_value !== (button0_class_value = ` ${/*btnColor*/
      ctx2[5]}  hover:bg-green-600  active:bg-green-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `)) {
        attr_dev(button0, "class", button0_class_value);
      }
      if (dirty & /*icon2*/
      256) set_data_dev(
        t7,
        /*icon2*/
        ctx2[8]
      );
      if (dirty & /*btn2Title*/
      16) set_data_dev(
        t8,
        /*btn2Title*/
        ctx2[4]
      );
      if (dirty & /*btn2Color*/
      64 && button1_class_value !== (button1_class_value = ` ${/*btn2Color*/
      ctx2[6]}  hover:bg-gray-400  active:bg-gray-300   text-white font-bold py-2 px-4 rounded w-full sm:w-4/12 m-1 `)) {
        attr_dev(button1, "class", button1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance23($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputFormCancel", slots, []);
  let newTitle = "";
  let { clk = () => true } = $$props;
  let { clk2 = () => true } = $$props;
  let { title = "Create New" } = $$props;
  let { btnTitle = "New" } = $$props;
  let { btn2Title = "Hide" } = $$props;
  let { btnColor = "bg-green-800" } = $$props;
  let { btn2Color = "bg-gray-600" } = $$props;
  let { icon = "💡" } = $$props;
  let { icon2 = "🙈" } = $$props;
  let { comment = "" } = $$props;
  const writable_props = [
    "clk",
    "clk2",
    "title",
    "btnTitle",
    "btn2Title",
    "btnColor",
    "btn2Color",
    "icon",
    "icon2",
    "comment"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<InputFormCancel> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    newTitle = this.value;
    $$invalidate(10, newTitle);
  }
  const click_handler = () => clk(newTitle);
  const click_handler_1 = () => clk2(newTitle);
  $$self.$$set = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("clk2" in $$props2) $$invalidate(1, clk2 = $$props2.clk2);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("btnTitle" in $$props2) $$invalidate(3, btnTitle = $$props2.btnTitle);
    if ("btn2Title" in $$props2) $$invalidate(4, btn2Title = $$props2.btn2Title);
    if ("btnColor" in $$props2) $$invalidate(5, btnColor = $$props2.btnColor);
    if ("btn2Color" in $$props2) $$invalidate(6, btn2Color = $$props2.btn2Color);
    if ("icon" in $$props2) $$invalidate(7, icon = $$props2.icon);
    if ("icon2" in $$props2) $$invalidate(8, icon2 = $$props2.icon2);
    if ("comment" in $$props2) $$invalidate(9, comment = $$props2.comment);
  };
  $$self.$capture_state = () => ({
    newTitle,
    clk,
    clk2,
    title,
    btnTitle,
    btn2Title,
    btnColor,
    btn2Color,
    icon,
    icon2,
    comment
  });
  $$self.$inject_state = ($$props2) => {
    if ("newTitle" in $$props2) $$invalidate(10, newTitle = $$props2.newTitle);
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("clk2" in $$props2) $$invalidate(1, clk2 = $$props2.clk2);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("btnTitle" in $$props2) $$invalidate(3, btnTitle = $$props2.btnTitle);
    if ("btn2Title" in $$props2) $$invalidate(4, btn2Title = $$props2.btn2Title);
    if ("btnColor" in $$props2) $$invalidate(5, btnColor = $$props2.btnColor);
    if ("btn2Color" in $$props2) $$invalidate(6, btn2Color = $$props2.btn2Color);
    if ("icon" in $$props2) $$invalidate(7, icon = $$props2.icon);
    if ("icon2" in $$props2) $$invalidate(8, icon2 = $$props2.icon2);
    if ("comment" in $$props2) $$invalidate(9, comment = $$props2.comment);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    clk,
    clk2,
    title,
    btnTitle,
    btn2Title,
    btnColor,
    btn2Color,
    icon,
    icon2,
    comment,
    newTitle,
    input_input_handler,
    click_handler,
    click_handler_1
  ];
}
var InputFormCancel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance23, create_fragment23, safe_not_equal, {
      clk: 0,
      clk2: 1,
      title: 2,
      btnTitle: 3,
      btn2Title: 4,
      btnColor: 5,
      btn2Color: 6,
      icon: 7,
      icon2: 8,
      comment: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputFormCancel",
      options,
      id: create_fragment23.name
    });
  }
  get clk() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk2() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk2(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnTitle() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnTitle(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btn2Title() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btn2Title(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btnColor() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btnColor(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get btn2Color() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set btn2Color(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon2() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon2(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get comment() {
    throw new Error("<InputFormCancel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set comment(value) {
    throw new Error("<InputFormCancel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputFormCancel_default = InputFormCancel;

// node_modules/sveltetools_bils/src/cmp/InputElm.svelte
var file24 = "node_modules/sveltetools_bils/src/cmp/InputElm.svelte";
function create_fragment24(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      attr_dev(input, "class", "w-full bg-gray-700 color-white p-2 m-1 rounded-md");
      add_location(input, file24, 8, 0, 71);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*item*/
        ctx[0][
          /*value*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*item, value*/
      3 && input.value !== /*item*/
      ctx2[0][
        /*value*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*item*/
          ctx2[0][
            /*value*/
            ctx2[1]
          ]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance24($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputElm", slots, []);
  let { item } = $$props;
  let { value } = $$props;
  $$self.$$.on_mount.push(function() {
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<InputElm> was created without expected prop 'item'");
    }
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<InputElm> was created without expected prop 'value'");
    }
  });
  const writable_props = ["item", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<InputElm> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    item[value] = this.value;
    $$invalidate(0, item);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ item, value });
  $$self.$inject_state = ($$props2) => {
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, value, input_input_handler];
}
var InputElm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance24, create_fragment24, safe_not_equal, { item: 0, value: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputElm",
      options,
      id: create_fragment24.name
    });
  }
  get item() {
    throw new Error("<InputElm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<InputElm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<InputElm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputElm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputElm_default = InputElm;

// node_modules/sveltetools_bils/src/cmp/InputEmail.svelte
var file25 = "node_modules/sveltetools_bils/src/cmp/InputEmail.svelte";
function create_fragment25(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "email");
      attr_dev(input, "class", "w-full bg-gray-700 color-white p-2 m-1 rounded-md");
      add_location(input, file25, 8, 0, 71);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*item*/
        ctx[0][
          /*value*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*item, value*/
      3 && input.value !== /*item*/
      ctx2[0][
        /*value*/
        ctx2[1]
      ]) {
        set_input_value(
          input,
          /*item*/
          ctx2[0][
            /*value*/
            ctx2[1]
          ]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance25($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputEmail", slots, []);
  let { value } = $$props;
  let { item } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<InputEmail> was created without expected prop 'value'");
    }
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<InputEmail> was created without expected prop 'item'");
    }
  });
  const writable_props = ["value", "item"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<InputEmail> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    item[value] = this.value;
    $$invalidate(0, item);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$capture_state = () => ({ value, item });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, value, input_input_handler];
}
var InputEmail = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance25, create_fragment25, safe_not_equal, { value: 1, item: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputEmail",
      options,
      id: create_fragment25.name
    });
  }
  get value() {
    throw new Error("<InputEmail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputEmail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get item() {
    throw new Error("<InputEmail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<InputEmail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputEmail_default = InputEmail;

// node_modules/sveltetools_bils/src/cmp/InputTextArea.svelte
var file26 = "node_modules/sveltetools_bils/src/cmp/InputTextArea.svelte";
function create_fragment26(ctx) {
  let textarea;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", { class: true });
      children(textarea).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(textarea, "class", "w-full bg-gray-700 color-white p-2 m-1 rounded-md");
      add_location(textarea, file26, 8, 1, 72);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, textarea, anchor);
      set_input_value(
        textarea,
        /*item*/
        ctx[0][
          /*value*/
          ctx[1]
        ]
      );
      if (!mounted) {
        dispose = listen_dev(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*item, value*/
      3) {
        set_input_value(
          textarea,
          /*item*/
          ctx2[0][
            /*value*/
            ctx2[1]
          ]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(textarea);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance26($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("InputTextArea", slots, []);
  let { value } = $$props;
  let { item } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<InputTextArea> was created without expected prop 'value'");
    }
    if (item === void 0 && !("item" in $$props || $$self.$$.bound[$$self.$$.props["item"]])) {
      console.warn("<InputTextArea> was created without expected prop 'item'");
    }
  });
  const writable_props = ["value", "item"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<InputTextArea> was created with unknown prop '${key}'`);
  });
  function textarea_input_handler() {
    item[value] = this.value;
    $$invalidate(0, item);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  $$self.$capture_state = () => ({ value, item });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(1, value = $$props2.value);
    if ("item" in $$props2) $$invalidate(0, item = $$props2.item);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [item, value, textarea_input_handler];
}
var InputTextArea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance26, create_fragment26, safe_not_equal, { value: 1, item: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InputTextArea",
      options,
      id: create_fragment26.name
    });
  }
  get value() {
    throw new Error("<InputTextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<InputTextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get item() {
    throw new Error("<InputTextArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set item(value) {
    throw new Error("<InputTextArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var InputTextArea_default = InputTextArea;

// node_modules/sveltetools_bils/src/cmp/Li.svelte
var file27 = "node_modules/sveltetools_bils/src/cmp/Li.svelte";
function create_fragment27(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `${/*bgColor*/
      ctx[0]}  mx-4  p-1  my-2 rounded-sm pl-3`);
      add_location(div, file27, 8, 2, 98);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      1 && div_class_value !== (div_class_value = `${/*bgColor*/
      ctx2[0]}  mx-4  p-1  my-2 rounded-sm pl-3`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance27($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Li", slots, ["default"]);
  let { bgColor = "bg-gray-900" } = $$props;
  const writable_props = ["bgColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Li> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, $$scope, slots];
}
var Li = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance27, create_fragment27, safe_not_equal, { bgColor: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Li",
      options,
      id: create_fragment27.name
    });
  }
  get bgColor() {
    throw new Error("<Li>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Li>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Li_default = Li;

// node_modules/sveltetools_bils/src/cmp/Logo.svelte
var file28 = "node_modules/sveltetools_bils/src/cmp/Logo.svelte";
function create_fragment28(ctx) {
  let div1;
  let div0;
  let a;
  let button;
  let span0;
  let textContent = "🏠";
  let t1;
  let span1;
  let textContent_1 = "BackOffice";
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      a = element("a");
      button = element("button");
      span0 = element("span");
      span0.textContent = textContent;
      t1 = space();
      span1 = element("span");
      span1.textContent = textContent_1;
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      a = claim_element(div0_nodes, "A", { href: true });
      var a_nodes = children(a);
      button = claim_element(a_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span0) !== "svelte-d8yi6b") span0.textContent = textContent;
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(span1) !== "svelte-wtxsc7") span1.textContent = textContent_1;
      button_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-md");
      add_location(span0, file28, 13, 6, 293);
      attr_dev(span1, "class", "text-xs font-md text-white");
      add_location(span1, file28, 14, 6, 338);
      attr_dev(button, "class", "w-full flex flex-col items-center p-1 m-0 rounded hover:bg-gray-500 active:bg-gray-900");
      add_location(button, file28, 12, 4, 182);
      attr_dev(
        a,
        "href",
        /*url*/
        ctx[0]
      );
      add_location(a, file28, 11, 2, 163);
      attr_dev(div0, "class", "w-15");
      add_location(div0, file28, 10, 0, 142);
      attr_dev(div1, "class", "flex justify-between items-center");
      add_location(div1, file28, 6, 4, 91);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, a);
      append_hydration_dev(a, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*url*/
      1) {
        attr_dev(
          a,
          "href",
          /*url*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance28($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Logo", slots, []);
  let { url } = $$props;
  $$self.$$.on_mount.push(function() {
    if (url === void 0 && !("url" in $$props || $$self.$$.bound[$$self.$$.props["url"]])) {
      console.warn("<Logo> was created without expected prop 'url'");
    }
  });
  const writable_props = ["url"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Logo> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
  };
  $$self.$capture_state = () => ({ url });
  $$self.$inject_state = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [url];
}
var Logo = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance28, create_fragment28, safe_not_equal, { url: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Logo",
      options,
      id: create_fragment28.name
    });
  }
  get url() {
    throw new Error("<Logo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Logo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Logo_default = Logo;

// node_modules/sveltetools_bils/src/cmp/Lbl.svelte
var file29 = "node_modules/sveltetools_bils/src/cmp/Lbl.svelte";
function create_fragment29(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "bg-gray-700 text-lg text-center px-10 py-2 rounded-md ");
      add_location(div, file29, 8, 0, 25);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance29($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Lbl", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Lbl> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var Lbl = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance29, create_fragment29, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lbl",
      options,
      id: create_fragment29.name
    });
  }
};
var Lbl_default = Lbl;

// node_modules/sveltetools_bils/src/cmp/Loading.svelte
var file30 = "node_modules/sveltetools_bils/src/cmp/Loading.svelte";
function create_fragment30(ctx) {
  let div;
  let span0;
  let t0;
  let span0_class_value;
  let t1;
  let span1;
  let t2;
  let span1_class_value;
  const block = {
    c: function create() {
      div = element("div");
      span0 = element("span");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      span1 = element("span");
      t2 = text("⏱");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span0 = claim_element(div_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*title*/
        ctx[0]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      span1 = claim_element(div_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "⏱");
      span1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", span0_class_value = `text-${/*size*/
      ctx[1]}xl`);
      add_location(span0, file30, 15, 2, 277);
      attr_dev(span1, "class", span1_class_value = `text-${/*size*/
      ctx[1]}xl`);
      add_location(span1, file30, 16, 2, 327);
      attr_dev(div, "class", "p-8 mx-auto mt-12 w-6/12 bg-gray-500 border-2 border-gray-200 text-white text-center text-3xl");
      add_location(div, file30, 12, 0, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, span1);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*title*/
      1) set_data_dev(
        t0,
        /*title*/
        ctx2[0]
      );
      if (dirty & /*size*/
      2 && span0_class_value !== (span0_class_value = `text-${/*size*/
      ctx2[1]}xl`)) {
        attr_dev(span0, "class", span0_class_value);
      }
      if (dirty & /*size*/
      2 && span1_class_value !== (span1_class_value = `text-${/*size*/
      ctx2[1]}xl`)) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance30($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Loading", slots, []);
  let { title = "loading..." } = $$props;
  let size = 1;
  let interval = setInterval(
    () => {
      $$invalidate(1, size = size === 3 ? 1 : size + 1);
    },
    400
  );
  const writable_props = ["title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Loading> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ title, size, interval });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(0, title = $$props2.title);
    if ("size" in $$props2) $$invalidate(1, size = $$props2.size);
    if ("interval" in $$props2) interval = $$props2.interval;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, size];
}
var Loading = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance30, create_fragment30, safe_not_equal, { title: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Loading",
      options,
      id: create_fragment30.name
    });
  }
  get title() {
    throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Loading_default = Loading;

// node_modules/sveltetools_bils/src/cmp/LinkIconOval.svelte
var file31 = "node_modules/sveltetools_bils/src/cmp/LinkIconOval.svelte";
function create_fragment31(ctx) {
  let div;
  let a;
  let span;
  let t;
  let span_class_value;
  let a_class_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      span = element("span");
      t = text(
        /*icon*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      span = claim_element(a_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*icon*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = `${/*textSize*/
      ctx[3]}`);
      add_location(span, file31, 12, 4, 295);
      attr_dev(a, "class", a_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`);
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[2]
      );
      add_location(a, file31, 8, 2, 171);
      attr_dev(div, "class", "flex justify-center");
      add_location(div, file31, 7, 0, 135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      1) set_data_dev(
        t,
        /*icon*/
        ctx2[0]
      );
      if (dirty & /*textSize*/
      8 && span_class_value !== (span_class_value = `${/*textSize*/
      ctx2[3]}`)) {
        attr_dev(span, "class", span_class_value);
      }
      if (dirty & /*bgColor*/
      2 && a_class_value !== (a_class_value = `flex border-1 justify-center ${/*bgColor*/
      ctx2[1]} hover:bg-gray-300 rounded-lg px-2 py-1 m-1`)) {
        attr_dev(a, "class", a_class_value);
      }
      if (dirty & /*href*/
      4) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance31($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LinkIconOval", slots, []);
  let { icon = "⚙️" } = $$props;
  let { bgColor = "bg-gray-700" } = $$props;
  let { href = "" } = $$props;
  let { textSize = "text-md" } = $$props;
  const writable_props = ["icon", "bgColor", "href", "textSize"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<LinkIconOval> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("href" in $$props2) $$invalidate(2, href = $$props2.href);
    if ("textSize" in $$props2) $$invalidate(3, textSize = $$props2.textSize);
  };
  $$self.$capture_state = () => ({ icon, bgColor, href, textSize });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("bgColor" in $$props2) $$invalidate(1, bgColor = $$props2.bgColor);
    if ("href" in $$props2) $$invalidate(2, href = $$props2.href);
    if ("textSize" in $$props2) $$invalidate(3, textSize = $$props2.textSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, bgColor, href, textSize];
}
var LinkIconOval = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance31, create_fragment31, safe_not_equal, {
      icon: 0,
      bgColor: 1,
      href: 2,
      textSize: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LinkIconOval",
      options,
      id: create_fragment31.name
    });
  }
  get icon() {
    throw new Error("<LinkIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<LinkIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<LinkIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<LinkIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<LinkIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<LinkIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textSize() {
    throw new Error("<LinkIconOval>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textSize(value) {
    throw new Error("<LinkIconOval>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LinkIconOval_default = LinkIconOval;

// node_modules/sveltetools_bils/src/cmp/NavBar.svelte
var file32 = "node_modules/sveltetools_bils/src/cmp/NavBar.svelte";
function create_fragment32(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `${/*bgColor*/
      ctx[0]} p-0  px-1 m-0`);
      add_location(div, file32, 6, 2, 60);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      1 && div_class_value !== (div_class_value = `${/*bgColor*/
      ctx2[0]} p-0  px-1 m-0`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance32($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavBar", slots, ["default"]);
  let { bgColor = "bg-gray-700" } = $$props;
  const writable_props = ["bgColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavBar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, $$scope, slots];
}
var NavBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance32, create_fragment32, safe_not_equal, { bgColor: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavBar",
      options,
      id: create_fragment32.name
    });
  }
  get bgColor() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavBar_default = NavBar;

// node_modules/sveltetools_bils/src/cmp/NavBtn.svelte
var file33 = "node_modules/sveltetools_bils/src/cmp/NavBtn.svelte";
function create_fragment33(ctx) {
  let div;
  let a;
  let button;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let a_href_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      button = element("button");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[1]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*title*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true });
      var a_nodes = children(a);
      button = claim_element(a_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[1]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*title*/
        ctx[2]
      );
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-md");
      add_location(span0, file33, 10, 6, 312);
      attr_dev(span1, "class", "text-xs font-md text-white");
      add_location(span1, file33, 11, 6, 354);
      attr_dev(button, "class", "w-full flex flex-col items-center p-2 m-0 rounded hover:bg-gray-500 active:bg-gray-900");
      add_location(button, file33, 9, 4, 201);
      attr_dev(a, "href", a_href_value = `${/*url*/
      ctx[0]}`);
      add_location(a, file33, 8, 2, 175);
      attr_dev(div, "class", "w-15 hover:bg-gray-700 rounded-md");
      add_location(div, file33, 7, 0, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      2) set_data_dev(
        t0,
        /*icon*/
        ctx2[1]
      );
      if (dirty & /*title*/
      4) set_data_dev(
        t2,
        /*title*/
        ctx2[2]
      );
      if (dirty & /*url*/
      1 && a_href_value !== (a_href_value = `${/*url*/
      ctx2[0]}`)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance33($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavBtn", slots, []);
  let { url = "https://google.com" } = $$props;
  let { icon = "🧪" } = $$props;
  let { title = "Menu" } = $$props;
  const writable_props = ["url", "icon", "title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavBtn> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ url, icon, title });
  $$self.$inject_state = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [url, icon, title];
}
var NavBtn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance33, create_fragment33, safe_not_equal, { url: 0, icon: 1, title: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavBtn",
      options,
      id: create_fragment33.name
    });
  }
  get url() {
    throw new Error("<NavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<NavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<NavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<NavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavBtn_default = NavBtn;

// node_modules/sveltetools_bils/src/cmp/NavLink.svelte
var file34 = "node_modules/sveltetools_bils/src/cmp/NavLink.svelte";
function create_fragment34(ctx) {
  let div;
  let a;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let a_href_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[1]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*title*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { href: true, class: true, target: true });
      var a_nodes = children(a);
      span0 = claim_element(a_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[1]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(a_nodes);
      span1 = claim_element(a_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*title*/
        ctx[2]
      );
      span1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-md");
      add_location(span0, file34, 9, 6, 314);
      attr_dev(span1, "class", "text-xs font-md text-white");
      add_location(span1, file34, 10, 6, 356);
      attr_dev(a, "href", a_href_value = `${/*url*/
      ctx[0]}`);
      attr_dev(a, "class", "w-full flex flex-col items-center p-2 m-0 rounded hover:bg-gray-500 active:bg-gray-900");
      attr_dev(a, "target", "_blank");
      add_location(a, file34, 8, 2, 175);
      attr_dev(div, "class", "w-15 hover:bg-gray-700 rounded-md");
      add_location(div, file34, 7, 0, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(a, t1);
      append_hydration_dev(a, span1);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      2) set_data_dev(
        t0,
        /*icon*/
        ctx2[1]
      );
      if (dirty & /*title*/
      4) set_data_dev(
        t2,
        /*title*/
        ctx2[2]
      );
      if (dirty & /*url*/
      1 && a_href_value !== (a_href_value = `${/*url*/
      ctx2[0]}`)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance34($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavLink", slots, []);
  let { url = "https://google.com" } = $$props;
  let { icon = "🧪" } = $$props;
  let { title = "Menu" } = $$props;
  const writable_props = ["url", "icon", "title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavLink> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ url, icon, title });
  $$self.$inject_state = ($$props2) => {
    if ("url" in $$props2) $$invalidate(0, url = $$props2.url);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [url, icon, title];
}
var NavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance34, create_fragment34, safe_not_equal, { url: 0, icon: 1, title: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavLink",
      options,
      id: create_fragment34.name
    });
  }
  get url() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavLink_default = NavLink;

// node_modules/sveltetools_bils/src/cmp/NavBtn2.svelte
var file35 = "node_modules/sveltetools_bils/src/cmp/NavBtn2.svelte";
function create_fragment35(ctx) {
  let div;
  let button;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let button_class_value;
  let div_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[1]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*title*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[1]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*title*/
        ctx[2]
      );
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-md");
      add_location(span0, file35, 13, 10, 361);
      attr_dev(span1, "class", "text-xs font-medium text-white");
      add_location(span1, file35, 14, 10, 407);
      attr_dev(button, "class", button_class_value = `w-full flex flex-col items-center p-2 m-0 rounded hover:bg-gray-700 active:bg-gray-900`);
      add_location(button, file35, 9, 6, 203);
      attr_dev(div, "class", div_class_value = `w-16 ${/*bgColor*/
      ctx[3]} rounded-md`);
      add_location(div, file35, 8, 2, 154);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[0]
            )) ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      2) set_data_dev(
        t0,
        /*icon*/
        ctx[1]
      );
      if (dirty & /*title*/
      4) set_data_dev(
        t2,
        /*title*/
        ctx[2]
      );
      if (dirty & /*bgColor*/
      8 && div_class_value !== (div_class_value = `w-16 ${/*bgColor*/
      ctx[3]} rounded-md`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance35($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavBtn2", slots, []);
  let { clk } = $$props;
  let { icon = "🧪" } = $$props;
  let { title = "Menu" } = $$props;
  let { bgColor = "bg-gray-800" } = $$props;
  $$self.$$.on_mount.push(function() {
    if (clk === void 0 && !("clk" in $$props || $$self.$$.bound[$$self.$$.props["clk"]])) {
      console.warn("<NavBtn2> was created without expected prop 'clk'");
    }
  });
  const writable_props = ["clk", "icon", "title", "bgColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavBtn2> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("bgColor" in $$props2) $$invalidate(3, bgColor = $$props2.bgColor);
  };
  $$self.$capture_state = () => ({ clk, icon, title, bgColor });
  $$self.$inject_state = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("bgColor" in $$props2) $$invalidate(3, bgColor = $$props2.bgColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [clk, icon, title, bgColor];
}
var NavBtn2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance35, create_fragment35, safe_not_equal, { clk: 0, icon: 1, title: 2, bgColor: 3 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavBtn2",
      options,
      id: create_fragment35.name
    });
  }
  get clk() {
    throw new Error("<NavBtn2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<NavBtn2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<NavBtn2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<NavBtn2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<NavBtn2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<NavBtn2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bgColor() {
    throw new Error("<NavBtn2>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<NavBtn2>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavBtn2_default = NavBtn2;

// node_modules/sveltetools_bils/src/cmp/NavSec.svelte
var file36 = "node_modules/sveltetools_bils/src/cmp/NavSec.svelte";
function create_fragment36(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = ` ${/*bgColor*/
      ctx[0]} ${/*textColor*/
      ctx[1]} flex justify-left w-full m-0 p-1 pl-2 items-center px-1  py-1 gap-2`);
      add_location(div, file36, 5, 0, 91);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor, textColor*/
      3 && div_class_value !== (div_class_value = ` ${/*bgColor*/
      ctx2[0]} ${/*textColor*/
      ctx2[1]} flex justify-left w-full m-0 p-1 pl-2 items-center px-1  py-1 gap-2`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance36($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavSec", slots, ["default"]);
  let { bgColor = "bg-gray-500" } = $$props;
  let { textColor = "text-white" } = $$props;
  const writable_props = ["bgColor", "textColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavSec> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("textColor" in $$props2) $$invalidate(1, textColor = $$props2.textColor);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor, textColor });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("textColor" in $$props2) $$invalidate(1, textColor = $$props2.textColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, textColor, $$scope, slots];
}
var NavSec = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance36, create_fragment36, safe_not_equal, { bgColor: 0, textColor: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavSec",
      options,
      id: create_fragment36.name
    });
  }
  get bgColor() {
    throw new Error("<NavSec>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<NavSec>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textColor() {
    throw new Error("<NavSec>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textColor(value) {
    throw new Error("<NavSec>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavSec_default = NavSec;

// node_modules/sveltetools_bils/src/cmp/NumberElm.svelte
var file37 = "node_modules/sveltetools_bils/src/cmp/NumberElm.svelte";
function create_fragment37(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, class: true });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "number");
      attr_dev(input, "class", "w-full bg-gray-700 color-white p-2 m-1 rounded-md");
      add_location(input, file37, 7, 0, 54);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = listen_dev(
          input,
          "input",
          /*input_input_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*value*/
      1 && to_number(input.value) !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance37($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberElm", slots, []);
  let { value } = $$props;
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<NumberElm> was created without expected prop 'value'");
    }
  });
  const writable_props = ["value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NumberElm> was created with unknown prop '${key}'`);
  });
  function input_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ value });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, input_input_handler];
}
var NumberElm = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance37, create_fragment37, safe_not_equal, { value: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberElm",
      options,
      id: create_fragment37.name
    });
  }
  get value() {
    throw new Error("<NumberElm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberElm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberElm_default = NumberElm;

// node_modules/sveltetools_bils/src/cmp/PageNav.svelte
var file38 = "node_modules/sveltetools_bils/src/cmp/PageNav.svelte";
function create_fragment38(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `flex justify-left   items-center ${/*bgColor*/
      ctx[0]} p-1   gap-1`);
      add_location(div, file38, 5, 0, 57);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      1 && div_class_value !== (div_class_value = `flex justify-left   items-center ${/*bgColor*/
      ctx2[0]} p-1   gap-1`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance38($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageNav", slots, ["default"]);
  let { bgColor = "bg-gray-400" } = $$props;
  const writable_props = ["bgColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PageNav> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, $$scope, slots];
}
var PageNav = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance38, create_fragment38, safe_not_equal, { bgColor: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageNav",
      options,
      id: create_fragment38.name
    });
  }
  get bgColor() {
    throw new Error("<PageNav>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<PageNav>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PageNav_default = PageNav;

// node_modules/sveltetools_bils/src/cmp/PageNavBtn.svelte
var { console: console_14 } = globals;
var file39 = "node_modules/sveltetools_bils/src/cmp/PageNavBtn.svelte";
function create_fragment39(ctx) {
  let div;
  let button;
  let span0;
  let t0_value = `${/*icon*/
  ctx[0]}`;
  let t0;
  let t1;
  let span1;
  let t2_value = `${/*title*/
  ctx[1]}`;
  let t2;
  let span1_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, t2_value);
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-2xl");
      add_location(span0, file39, 14, 4, 377);
      attr_dev(span1, "class", span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx[2] == true ? (
        /*trueColor*/
        ctx[4]
      ) : (
        /*falseColor*/
        ctx[5]
      )));
      add_location(span1, file39, 15, 4, 423);
      attr_dev(button, "class", "w-full flex flex-col items-center p-2 bg-gray-800 rounded hover:bg-gray-700 active:bg-gray-900");
      add_location(button, file39, 12, 2, 242);
      attr_dev(div, "class", "w-20");
      add_location(div, file39, 11, 1, 221);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[3]
            )) ctx[3].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      1 && t0_value !== (t0_value = `${/*icon*/
      ctx[0]}`)) set_data_dev(t0, t0_value);
      if (dirty & /*title*/
      2 && t2_value !== (t2_value = `${/*title*/
      ctx[1]}`)) set_data_dev(t2, t2_value);
      if (dirty & /*tf, trueColor, falseColor*/
      52 && span1_class_value !== (span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx[2] == true ? (
        /*trueColor*/
        ctx[4]
      ) : (
        /*falseColor*/
        ctx[5]
      )))) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance39($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageNavBtn", slots, []);
  let { icon = "📜" } = $$props;
  let { title = "Title" } = $$props;
  let { tf = true } = $$props;
  let { clk = () => console.log("Toolbar Btn") } = $$props;
  let { trueColor = "text-green-400" } = $$props;
  let { falseColor = "text-red-400" } = $$props;
  const writable_props = ["icon", "title", "tf", "clk", "trueColor", "falseColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_14.warn(`<PageNavBtn> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    tf,
    clk,
    trueColor,
    falseColor
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, tf, clk, trueColor, falseColor];
}
var PageNavBtn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance39, create_fragment39, safe_not_equal, {
      icon: 0,
      title: 1,
      tf: 2,
      clk: 3,
      trueColor: 4,
      falseColor: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageNavBtn",
      options,
      id: create_fragment39.name
    });
  }
  get icon() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tf() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tf(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trueColor() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trueColor(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get falseColor() {
    throw new Error("<PageNavBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set falseColor(value) {
    throw new Error("<PageNavBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PageNavBtn_default = PageNavBtn;

// node_modules/sveltetools_bils/src/cmp/PageNavLink.svelte
var file40 = "node_modules/sveltetools_bils/src/cmp/PageNavLink.svelte";
function create_fragment40(ctx) {
  let div;
  let a;
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  let span1_class_value;
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      span0 = element("span");
      t0 = text(
        /*icon*/
        ctx[0]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      a = claim_element(div_nodes, "A", { class: true, href: true });
      var a_nodes = children(a);
      span0 = claim_element(a_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*icon*/
        ctx[0]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(a_nodes);
      span1 = claim_element(a_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*title*/
        ctx[1]
      );
      span1_nodes.forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-2xl");
      add_location(span0, file40, 14, 4, 343);
      attr_dev(span1, "class", span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx[2] == true ? (
        /*trueColor*/
        ctx[4]
      ) : (
        /*falseColor*/
        ctx[5]
      )));
      add_location(span1, file40, 15, 4, 384);
      attr_dev(a, "class", "w-full flex flex-col items-center p-2 bg-gray-800 rounded hover:bg-gray-700 active:bg-gray-900");
      attr_dev(
        a,
        "href",
        /*href*/
        ctx[3]
      );
      add_location(a, file40, 12, 2, 217);
      attr_dev(div, "class", "w-20");
      add_location(div, file40, 11, 1, 196);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, a);
      append_hydration_dev(a, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(a, t1);
      append_hydration_dev(a, span1);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*icon*/
      1) set_data_dev(
        t0,
        /*icon*/
        ctx2[0]
      );
      if (dirty & /*title*/
      2) set_data_dev(
        t2,
        /*title*/
        ctx2[1]
      );
      if (dirty & /*tf, trueColor, falseColor*/
      52 && span1_class_value !== (span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx2[2] == true ? (
        /*trueColor*/
        ctx2[4]
      ) : (
        /*falseColor*/
        ctx2[5]
      )))) {
        attr_dev(span1, "class", span1_class_value);
      }
      if (dirty & /*href*/
      8) {
        attr_dev(
          a,
          "href",
          /*href*/
          ctx2[3]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance40($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageNavLink", slots, []);
  let { icon = "📜" } = $$props;
  let { title = "Title" } = $$props;
  let { tf = true } = $$props;
  let { href = "/" } = $$props;
  let { trueColor = "text-green-400" } = $$props;
  let { falseColor = "text-red-400" } = $$props;
  const writable_props = ["icon", "title", "tf", "href", "trueColor", "falseColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PageNavLink> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("href" in $$props2) $$invalidate(3, href = $$props2.href);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    tf,
    href,
    trueColor,
    falseColor
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("href" in $$props2) $$invalidate(3, href = $$props2.href);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, tf, href, trueColor, falseColor];
}
var PageNavLink = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance40, create_fragment40, safe_not_equal, {
      icon: 0,
      title: 1,
      tf: 2,
      href: 3,
      trueColor: 4,
      falseColor: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageNavLink",
      options,
      id: create_fragment40.name
    });
  }
  get icon() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tf() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tf(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trueColor() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trueColor(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get falseColor() {
    throw new Error("<PageNavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set falseColor(value) {
    throw new Error("<PageNavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PageNavLink_default = PageNavLink;

// node_modules/sveltetools_bils/src/cmp/P.svelte
var file41 = "node_modules/sveltetools_bils/src/cmp/P.svelte";
function create_fragment41(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = `${/*bgColor*/
      ctx[0]} ${/*textColor*/
      ctx[1]} text-lg p-1 m-1 mb-2 mx-4`);
      add_location(div, file41, 8, 0, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor, textColor*/
      3 && div_class_value !== (div_class_value = `${/*bgColor*/
      ctx2[0]} ${/*textColor*/
      ctx2[1]} text-lg p-1 m-1 mb-2 mx-4`)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance41($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("P", slots, ["default"]);
  let { bgColor = "bg-gray-800" } = $$props;
  let { textColor = "text-white" } = $$props;
  const writable_props = ["bgColor", "textColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<P> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("textColor" in $$props2) $$invalidate(1, textColor = $$props2.textColor);
    if ("$$scope" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor, textColor });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("textColor" in $$props2) $$invalidate(1, textColor = $$props2.textColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, textColor, $$scope, slots];
}
var P = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance41, create_fragment41, safe_not_equal, { bgColor: 0, textColor: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "P",
      options,
      id: create_fragment41.name
    });
  }
  get bgColor() {
    throw new Error("<P>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<P>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textColor() {
    throw new Error("<P>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textColor(value) {
    throw new Error("<P>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var P_default = P;

// node_modules/sveltetools_bils/src/cmp/PageWrapper.svelte
var file42 = "node_modules/sveltetools_bils/src/cmp/PageWrapper.svelte";
function create_fragment42(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[1].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[0],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "bg-gray-800 w-full text-white min-h-screen p-0 m-0");
      add_location(div, file42, 4, 0, 4);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[0],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[0]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[0],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance42($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PageWrapper", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PageWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var PageWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance42, create_fragment42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PageWrapper",
      options,
      id: create_fragment42.name
    });
  }
};
var PageWrapper_default = PageWrapper;

// node_modules/sveltetools_bils/src/cmp/ProgressBar.svelte
var file43 = "node_modules/sveltetools_bils/src/cmp/ProgressBar.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let div;
  let t0_value = (
    /*number*/
    ctx[3] + 1 + ""
  );
  let t0;
  let t1;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t0 = text(t0_value);
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t0 = claim_text(div_nodes, t0_value);
      t1 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = "p-1 m-1 text-xs " + /*number*/
      (ctx[3] == /*current*/
      ctx[0] ? "bg-green-500" : "bg-blue-900"));
      add_location(div, file43, 11, 0, 214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t0);
      append_hydration_dev(div, t1);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*current*/
      1 && div_class_value !== (div_class_value = "p-1 m-1 text-xs " + /*number*/
      (ctx2[3] == /*current*/
      ctx2[0] ? "bg-green-500" : "bg-blue-900"))) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(11:0) {#each numbers as number}",
    ctx
  });
  return block;
}
function create_fragment43(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*numbers*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "flex rounded-sm justify-center ");
      add_location(div, file43, 8, 0, 132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*numbers, current*/
      3) {
        each_value = ensure_array_like_dev(
          /*numbers*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance43($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ProgressBar", slots, []);
  let { total } = $$props;
  let { current } = $$props;
  let numbers = Array.from({ length: total }, (_, i) => i);
  $$self.$$.on_mount.push(function() {
    if (total === void 0 && !("total" in $$props || $$self.$$.bound[$$self.$$.props["total"]])) {
      console.warn("<ProgressBar> was created without expected prop 'total'");
    }
    if (current === void 0 && !("current" in $$props || $$self.$$.bound[$$self.$$.props["current"]])) {
      console.warn("<ProgressBar> was created without expected prop 'current'");
    }
  });
  const writable_props = ["total", "current"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ProgressBar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("total" in $$props2) $$invalidate(2, total = $$props2.total);
    if ("current" in $$props2) $$invalidate(0, current = $$props2.current);
  };
  $$self.$capture_state = () => ({ total, current, numbers });
  $$self.$inject_state = ($$props2) => {
    if ("total" in $$props2) $$invalidate(2, total = $$props2.total);
    if ("current" in $$props2) $$invalidate(0, current = $$props2.current);
    if ("numbers" in $$props2) $$invalidate(1, numbers = $$props2.numbers);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [current, numbers, total];
}
var ProgressBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance43, create_fragment43, safe_not_equal, { total: 2, current: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ProgressBar",
      options,
      id: create_fragment43.name
    });
  }
  get total() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set total(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get current() {
    throw new Error("<ProgressBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set current(value) {
    throw new Error("<ProgressBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ProgressBar_default = ProgressBar;

// node_modules/sveltetools_bils/src/cmp/Range.svelte
var file44 = "node_modules/sveltetools_bils/src/cmp/Range.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1909mwk", ".range-label.svelte-1909mwk{font-size:14px;font-weight:bold}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUmFuZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1CRSwyQkFBYSxDQUNYLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLElBQ2YiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIlJhbmdlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment44(ctx) {
  let input;
  let t0;
  let span;
  let t1;
  let t2;
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      t0 = space();
      span = element("span");
      t1 = text(
        /*value*/
        ctx[0]
      );
      t2 = text("/");
      t3 = text(
        /*max*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true, min: true, max: true });
      t0 = claim_space(nodes);
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t1 = claim_text(
        span_nodes,
        /*value*/
        ctx[0]
      );
      t2 = claim_text(span_nodes, "/");
      t3 = claim_text(
        span_nodes,
        /*max*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "range");
      attr_dev(
        input,
        "min",
        /*min*/
        ctx[1]
      );
      attr_dev(
        input,
        "max",
        /*max*/
        ctx[2]
      );
      add_location(input, file44, 15, 0, 211);
      attr_dev(span, "class", "range-label svelte-1909mwk");
      add_location(span, file44, 16, 0, 273);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[3]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*min*/
      2) {
        attr_dev(
          input,
          "min",
          /*min*/
          ctx2[1]
        );
      }
      if (dirty & /*max*/
      4) {
        attr_dev(
          input,
          "max",
          /*max*/
          ctx2[2]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
      if (dirty & /*value*/
      1) set_data_dev(
        t1,
        /*value*/
        ctx2[0]
      );
      if (dirty & /*max*/
      4) set_data_dev(
        t3,
        /*max*/
        ctx2[2]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
        detach_dev(t0);
        detach_dev(span);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance44($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Range", slots, []);
  let { min = 1 } = $$props;
  let { max = 12 } = $$props;
  let { value = 6 } = $$props;
  onMount(() => {
    if (value < min) {
      $$invalidate(0, value = min);
    }
  });
  const writable_props = ["min", "max", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Range> was created with unknown prop '${key}'`);
  });
  function input_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("min" in $$props2) $$invalidate(1, min = $$props2.min);
    if ("max" in $$props2) $$invalidate(2, max = $$props2.max);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ onMount, min, max, value });
  $$self.$inject_state = ($$props2) => {
    if ("min" in $$props2) $$invalidate(1, min = $$props2.min);
    if ("max" in $$props2) $$invalidate(2, max = $$props2.max);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, min, max, input_change_input_handler];
}
var Range = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance44, create_fragment44, safe_not_equal, { min: 1, max: 2, value: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Range",
      options,
      id: create_fragment44.name
    });
  }
  get min() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Range>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Range>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Range_default = Range;

// node_modules/sveltetools_bils/src/cmp/SectionHead.svelte
var file45 = "node_modules/sveltetools_bils/src/cmp/SectionHead.svelte";
function create_if_block5(ctx) {
  let div;
  let div_intro;
  let div_outro;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file45, 39, 0, 985);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div_outro) div_outro.end(1);
          div_intro = create_in_transition(div, fade, { delay: 300 });
          div_intro.start();
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      if (div_intro) div_intro.invalidate();
      if (local) {
        div_outro = create_out_transition(div, fade, { delay: 300 });
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot) default_slot.d(detaching);
      if (detaching && div_outro) div_outro.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(38:0) {#if visible==true}",
    ctx
  });
  return block;
}
function create_fragment45(ctx) {
  let div3;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2;
  let span;
  let t4_value = (
    /*visible*/
    ctx[0] == true ? "-" : "+"
  );
  let t4;
  let div3_intro;
  let div3_outro;
  let t5;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*visible*/
    ctx[0] == true && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(
        /*icon*/
        ctx[2]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*title*/
        ctx[1]
      );
      t3 = space();
      div2 = element("div");
      span = element("span");
      t4 = text(t4_value);
      t5 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*icon*/
        ctx[2]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*title*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      span = claim_element(div2_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t4 = claim_text(span_nodes, t4_value);
      span_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t5 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "flex items-center justify-center w-3/12 p-0 bg-gray-900 text-xl rounded-t-lg border border-gray-400 ");
      add_location(div0, file45, 15, 4, 321);
      attr_dev(div1, "class", "text-center w-full p-2 bg-gray-700");
      add_location(div1, file45, 19, 4, 474);
      attr_dev(span, "class", "text-3xl");
      add_location(span, file45, 30, 8, 874);
      attr_dev(div2, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div2, file45, 26, 4, 696);
      attr_dev(div3, "class", "flex rounded-t-lg border border-gray-400 p-0 ");
      add_location(div3, file45, 11, 0, 203);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, span);
      append_hydration_dev(span, t4);
      insert_hydration_dev(target, t5, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div2,
          "click",
          /*toggleVisibility*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      4) set_data_dev(
        t0,
        /*icon*/
        ctx2[2]
      );
      if (!current || dirty & /*title*/
      2) set_data_dev(
        t2,
        /*title*/
        ctx2[1]
      );
      if ((!current || dirty & /*visible*/
      1) && t4_value !== (t4_value = /*visible*/
      ctx2[0] == true ? "-" : "+")) set_data_dev(t4, t4_value);
      if (
        /*visible*/
        ctx2[0] == true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      if (local) {
        add_render_callback(() => {
          if (!current) return;
          if (div3_outro) div3_outro.end(1);
          div3_intro = create_in_transition(div3, fade, { delay: 300 });
          div3_intro.start();
        });
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      if (div3_intro) div3_intro.invalidate();
      if (local) {
        div3_outro = create_out_transition(div3, fade, { delay: 300 });
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
        detach_dev(t5);
        detach_dev(if_block_anchor);
      }
      if (detaching && div3_outro) div3_outro.end();
      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance45($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SectionHead", slots, ["default"]);
  let { title } = $$props;
  let { icon = "⚙" } = $$props;
  let { visible = false } = $$props;
  const toggleVisibility = () => $$invalidate(0, visible = !visible);
  $$self.$$.on_mount.push(function() {
    if (title === void 0 && !("title" in $$props || $$self.$$.bound[$$self.$$.props["title"]])) {
      console.warn("<SectionHead> was created without expected prop 'title'");
    }
  });
  const writable_props = ["title", "icon", "visible"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SectionHead> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
    if ("$$scope" in $$props2) $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    title,
    icon,
    visible,
    fade,
    toggleVisibility
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visible, title, icon, toggleVisibility, $$scope, slots];
}
var SectionHead = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance45, create_fragment45, safe_not_equal, { title: 1, icon: 2, visible: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SectionHead",
      options,
      id: create_fragment45.name
    });
  }
  get title() {
    throw new Error("<SectionHead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SectionHead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SectionHead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SectionHead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<SectionHead>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<SectionHead>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SectionHead_default = SectionHead;

// node_modules/sveltetools_bils/src/cmp/SmallBtnToolbar.svelte
var file46 = "node_modules/sveltetools_bils/src/cmp/SmallBtnToolbar.svelte";
function create_fragment46(ctx) {
  let div1;
  let button;
  let t0;
  let t1;
  let div0;
  let t2;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div1 = element("div");
      button = element("button");
      t0 = text(
        /*icon*/
        ctx[1]
      );
      t1 = space();
      div0 = element("div");
      t2 = text(
        /*title*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      button = claim_element(div1_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t0 = claim_text(
        button_nodes,
        /*icon*/
        ctx[1]
      );
      button_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t2 = claim_text(
        div0_nodes,
        /*title*/
        ctx[2]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "bg-stone-500 p-1 rounded-md text-xs ");
      add_location(button, file46, 11, 4, 154);
      attr_dev(div0, "class", "text-xs p-1");
      add_location(div0, file46, 14, 4, 248);
      attr_dev(div1, "class", "flex flex-col hover:bg-gray-500 rounded-md p-1");
      add_location(div1, file46, 9, 0, 87);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, button);
      append_hydration_dev(button, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[0]
            )) ctx[0].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      2) set_data_dev(
        t0,
        /*icon*/
        ctx[1]
      );
      if (dirty & /*title*/
      4) set_data_dev(
        t2,
        /*title*/
        ctx[2]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance46($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SmallBtnToolbar", slots, []);
  let { clk } = $$props;
  let { icon } = $$props;
  let { title } = $$props;
  $$self.$$.on_mount.push(function() {
    if (clk === void 0 && !("clk" in $$props || $$self.$$.bound[$$self.$$.props["clk"]])) {
      console.warn("<SmallBtnToolbar> was created without expected prop 'clk'");
    }
    if (icon === void 0 && !("icon" in $$props || $$self.$$.bound[$$self.$$.props["icon"]])) {
      console.warn("<SmallBtnToolbar> was created without expected prop 'icon'");
    }
    if (title === void 0 && !("title" in $$props || $$self.$$.bound[$$self.$$.props["title"]])) {
      console.warn("<SmallBtnToolbar> was created without expected prop 'title'");
    }
  });
  const writable_props = ["clk", "icon", "title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SmallBtnToolbar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  $$self.$capture_state = () => ({ clk, icon, title });
  $$self.$inject_state = ($$props2) => {
    if ("clk" in $$props2) $$invalidate(0, clk = $$props2.clk);
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [clk, icon, title];
}
var SmallBtnToolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance46, create_fragment46, safe_not_equal, { clk: 0, icon: 1, title: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SmallBtnToolbar",
      options,
      id: create_fragment46.name
    });
  }
  get clk() {
    throw new Error("<SmallBtnToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<SmallBtnToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SmallBtnToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SmallBtnToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<SmallBtnToolbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SmallBtnToolbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SmallBtnToolbar_default = SmallBtnToolbar;

// node_modules/sveltetools_bils/src/cmp/SectionHeadAYS.svelte
var { console: console_15 } = globals;
var file47 = "node_modules/sveltetools_bils/src/cmp/SectionHeadAYS.svelte";
function create_if_block6(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(49:0) {#if visible==true}",
    ctx
  });
  return block;
}
function create_fragment47(ctx) {
  let div4;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2;
  let areyousure;
  let t4;
  let div3;
  let span;
  let t5_value = (
    /*visible*/
    ctx[0] == true ? "-" : "+"
  );
  let t5;
  let t6;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  areyousure = new AreYouSure_default({
    props: { deleteFn: (
      /*deleteFn*/
      ctx[3]
    ) },
    $$inline: true
  });
  let if_block = (
    /*visible*/
    ctx[0] == true && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      div4 = element("div");
      div0 = element("div");
      t0 = text(
        /*icon*/
        ctx[2]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*title*/
        ctx[1]
      );
      t3 = space();
      div2 = element("div");
      create_component(areyousure.$$.fragment);
      t4 = space();
      div3 = element("div");
      span = element("span");
      t5 = text(t5_value);
      t6 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div0 = claim_element(div4_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*icon*/
        ctx[2]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div1 = claim_element(div4_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*title*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div4_nodes);
      div2 = claim_element(div4_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(areyousure.$$.fragment, div2_nodes);
      div2_nodes.forEach(detach_dev);
      t4 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      span = claim_element(div3_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t5 = claim_text(span_nodes, t5_value);
      span_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      t6 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "flex items-center justify-center w-3/12 p-0 bg-gray-900 text-xl rounded-t-lg border border-gray-400 ");
      add_location(div0, file47, 15, 4, 322);
      attr_dev(div1, "class", "text-center w-full p-2 bg-gray-700");
      add_location(div1, file47, 19, 4, 475);
      attr_dev(div2, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div2, file47, 26, 4, 696);
      attr_dev(span, "class", "text-3xl");
      add_location(span, file47, 41, 8, 1192);
      attr_dev(div3, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div3, file47, 37, 4, 1014);
      attr_dev(div4, "class", "flex rounded-t-lg border border-gray-400 p-0 ");
      add_location(div4, file47, 13, 0, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div4, t3);
      append_hydration_dev(div4, div2);
      mount_component(areyousure, div2, null);
      append_hydration_dev(div4, t4);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, span);
      append_hydration_dev(span, t5);
      insert_hydration_dev(target, t6, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div3,
          "click",
          /*toggleVisibility*/
          ctx[4],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*icon*/
      4) set_data_dev(
        t0,
        /*icon*/
        ctx2[2]
      );
      if (!current || dirty & /*title*/
      2) set_data_dev(
        t2,
        /*title*/
        ctx2[1]
      );
      const areyousure_changes = {};
      if (dirty & /*deleteFn*/
      8) areyousure_changes.deleteFn = /*deleteFn*/
      ctx2[3];
      areyousure.$set(areyousure_changes);
      if ((!current || dirty & /*visible*/
      1) && t5_value !== (t5_value = /*visible*/
      ctx2[0] == true ? "-" : "+")) set_data_dev(t5, t5_value);
      if (
        /*visible*/
        ctx2[0] == true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(areyousure.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(areyousure.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
        detach_dev(t6);
        detach_dev(if_block_anchor);
      }
      destroy_component(areyousure);
      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance47($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SectionHeadAYS", slots, ["default"]);
  let { title } = $$props;
  let { icon = "⚙" } = $$props;
  let { deleteFn = () => console.log("Hello") } = $$props;
  let { visible = false } = $$props;
  const toggleVisibility = () => $$invalidate(0, visible = !visible);
  $$self.$$.on_mount.push(function() {
    if (title === void 0 && !("title" in $$props || $$self.$$.bound[$$self.$$.props["title"]])) {
      console_15.warn("<SectionHeadAYS> was created without expected prop 'title'");
    }
  });
  const writable_props = ["title", "icon", "deleteFn", "visible"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_15.warn(`<SectionHeadAYS> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("deleteFn" in $$props2) $$invalidate(3, deleteFn = $$props2.deleteFn);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
    if ("$$scope" in $$props2) $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    AreYouSure: AreYouSure_default,
    title,
    icon,
    deleteFn,
    visible,
    toggleVisibility
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("deleteFn" in $$props2) $$invalidate(3, deleteFn = $$props2.deleteFn);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visible, title, icon, deleteFn, toggleVisibility, $$scope, slots];
}
var SectionHeadAYS = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance47, create_fragment47, safe_not_equal, {
      title: 1,
      icon: 2,
      deleteFn: 3,
      visible: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SectionHeadAYS",
      options,
      id: create_fragment47.name
    });
  }
  get title() {
    throw new Error("<SectionHeadAYS>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SectionHeadAYS>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SectionHeadAYS>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SectionHeadAYS>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteFn() {
    throw new Error("<SectionHeadAYS>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteFn(value) {
    throw new Error("<SectionHeadAYS>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<SectionHeadAYS>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<SectionHeadAYS>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SectionHeadAYS_default = SectionHeadAYS;

// node_modules/sveltetools_bils/src/cmp/SectionHeadIcon.svelte
var { console: console_16 } = globals;
var file48 = "node_modules/sveltetools_bils/src/cmp/SectionHeadIcon.svelte";
function create_if_block7(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(59:0) {#if visible==true}",
    ctx
  });
  return block;
}
function create_fragment48(ctx) {
  let div5;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let div2;
  let t4;
  let t5;
  let div3;
  let areyousure;
  let t6;
  let div4;
  let span;
  let t7_value = (
    /*visible*/
    ctx[0] == true ? "-" : "+"
  );
  let t7;
  let t8;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  areyousure = new AreYouSure_default({
    props: { deleteFn: (
      /*deleteFn*/
      ctx[4]
    ) },
    $$inline: true
  });
  let if_block = (
    /*visible*/
    ctx[0] == true && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      div5 = element("div");
      div0 = element("div");
      t0 = text(
        /*ser*/
        ctx[3]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*title*/
        ctx[1]
      );
      t3 = space();
      div2 = element("div");
      t4 = text(
        /*icon*/
        ctx[2]
      );
      t5 = space();
      div3 = element("div");
      create_component(areyousure.$$.fragment);
      t6 = space();
      div4 = element("div");
      span = element("span");
      t7 = text(t7_value);
      t8 = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div0 = claim_element(div5_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*ser*/
        ctx[3]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div5_nodes);
      div1 = claim_element(div5_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*title*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div5_nodes);
      div2 = claim_element(div5_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      t4 = claim_text(
        div2_nodes,
        /*icon*/
        ctx[2]
      );
      div2_nodes.forEach(detach_dev);
      t5 = claim_space(div5_nodes);
      div3 = claim_element(div5_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      claim_component(areyousure.$$.fragment, div3_nodes);
      div3_nodes.forEach(detach_dev);
      t6 = claim_space(div5_nodes);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      span = claim_element(div4_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t7 = claim_text(span_nodes, t7_value);
      span_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      t8 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "flex items-center justify-center w-3/12 p-0 bg-gray-900 text-xl rounded-t-lg border border-gray-400 ");
      add_location(div0, file48, 16, 4, 344);
      attr_dev(div1, "class", "text-center w-full p-2 bg-gray-700");
      add_location(div1, file48, 20, 4, 496);
      attr_dev(div2, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div2, file48, 27, 4, 717);
      attr_dev(div3, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div3, file48, 36, 4, 1019);
      attr_dev(span, "class", "text-3xl");
      add_location(span, file48, 51, 8, 1515);
      attr_dev(div4, "class", "rounded-t-lg border border-gray-400 p-2 hover:cursor-pointer bg-gray-900 w-1/12 text-center hover:bg-gray-600");
      add_location(div4, file48, 47, 4, 1337);
      attr_dev(div5, "class", "flex rounded-t-lg border border-gray-400 p-0 ");
      add_location(div5, file48, 14, 0, 278);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div5, t1);
      append_hydration_dev(div5, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div5, t3);
      append_hydration_dev(div5, div2);
      append_hydration_dev(div2, t4);
      append_hydration_dev(div5, t5);
      append_hydration_dev(div5, div3);
      mount_component(areyousure, div3, null);
      append_hydration_dev(div5, t6);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, span);
      append_hydration_dev(span, t7);
      insert_hydration_dev(target, t8, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          div4,
          "click",
          /*toggleVisibility*/
          ctx[5],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*ser*/
      8) set_data_dev(
        t0,
        /*ser*/
        ctx2[3]
      );
      if (!current || dirty & /*title*/
      2) set_data_dev(
        t2,
        /*title*/
        ctx2[1]
      );
      if (!current || dirty & /*icon*/
      4) set_data_dev(
        t4,
        /*icon*/
        ctx2[2]
      );
      const areyousure_changes = {};
      if (dirty & /*deleteFn*/
      16) areyousure_changes.deleteFn = /*deleteFn*/
      ctx2[4];
      areyousure.$set(areyousure_changes);
      if ((!current || dirty & /*visible*/
      1) && t7_value !== (t7_value = /*visible*/
      ctx2[0] == true ? "-" : "+")) set_data_dev(t7, t7_value);
      if (
        /*visible*/
        ctx2[0] == true
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*visible*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(areyousure.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(areyousure.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div5);
        detach_dev(t8);
        detach_dev(if_block_anchor);
      }
      destroy_component(areyousure);
      if (if_block) if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance48($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SectionHeadIcon", slots, ["default"]);
  let { title } = $$props;
  let { icon = "⚙" } = $$props;
  let { ser = "1" } = $$props;
  let { deleteFn = () => console.log("Hello") } = $$props;
  let { visible = false } = $$props;
  const toggleVisibility = () => $$invalidate(0, visible = !visible);
  $$self.$$.on_mount.push(function() {
    if (title === void 0 && !("title" in $$props || $$self.$$.bound[$$self.$$.props["title"]])) {
      console_16.warn("<SectionHeadIcon> was created without expected prop 'title'");
    }
  });
  const writable_props = ["title", "icon", "ser", "deleteFn", "visible"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_16.warn(`<SectionHeadIcon> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("ser" in $$props2) $$invalidate(3, ser = $$props2.ser);
    if ("deleteFn" in $$props2) $$invalidate(4, deleteFn = $$props2.deleteFn);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
    if ("$$scope" in $$props2) $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    AreYouSure: AreYouSure_default,
    title,
    icon,
    ser,
    deleteFn,
    visible,
    toggleVisibility
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("icon" in $$props2) $$invalidate(2, icon = $$props2.icon);
    if ("ser" in $$props2) $$invalidate(3, ser = $$props2.ser);
    if ("deleteFn" in $$props2) $$invalidate(4, deleteFn = $$props2.deleteFn);
    if ("visible" in $$props2) $$invalidate(0, visible = $$props2.visible);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [visible, title, icon, ser, deleteFn, toggleVisibility, $$scope, slots];
}
var SectionHeadIcon = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance48, create_fragment48, safe_not_equal, {
      title: 1,
      icon: 2,
      ser: 3,
      deleteFn: 4,
      visible: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SectionHeadIcon",
      options,
      id: create_fragment48.name
    });
  }
  get title() {
    throw new Error("<SectionHeadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<SectionHeadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icon() {
    throw new Error("<SectionHeadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<SectionHeadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ser() {
    throw new Error("<SectionHeadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ser(value) {
    throw new Error("<SectionHeadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deleteFn() {
    throw new Error("<SectionHeadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deleteFn(value) {
    throw new Error("<SectionHeadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<SectionHeadIcon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<SectionHeadIcon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SectionHeadIcon_default = SectionHeadIcon;

// node_modules/sveltetools_bils/src/cmp/ShowIfTrue.svelte
function create_if_block8(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(7:4) {#if ifTrue}",
    ctx
  });
  return block;
}
function create_fragment49(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*ifTrue*/
    ctx[0] && create_if_block8(ctx)
  );
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*ifTrue*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*ifTrue*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance49($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ShowIfTrue", slots, ["default"]);
  let { ifTrue } = $$props;
  $$self.$$.on_mount.push(function() {
    if (ifTrue === void 0 && !("ifTrue" in $$props || $$self.$$.bound[$$self.$$.props["ifTrue"]])) {
      console.warn("<ShowIfTrue> was created without expected prop 'ifTrue'");
    }
  });
  const writable_props = ["ifTrue"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ShowIfTrue> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("ifTrue" in $$props2) $$invalidate(0, ifTrue = $$props2.ifTrue);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ ifTrue });
  $$self.$inject_state = ($$props2) => {
    if ("ifTrue" in $$props2) $$invalidate(0, ifTrue = $$props2.ifTrue);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [ifTrue, $$scope, slots];
}
var ShowIfTrue = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance49, create_fragment49, safe_not_equal, { ifTrue: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShowIfTrue",
      options,
      id: create_fragment49.name
    });
  }
  get ifTrue() {
    throw new Error("<ShowIfTrue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ifTrue(value) {
    throw new Error("<ShowIfTrue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ShowIfTrue_default = ShowIfTrue;

// node_modules/sveltetools_bils/src/cmp/Tf.svelte
var file49 = "node_modules/sveltetools_bils/src/cmp/Tf.svelte";
function create_else_block2(ctx) {
  let button;
  let textContent = "False";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-cu7at5") button.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "w-full bg-red-500 hover:bg-red-700 active:bg-red-900 text-white font-bold py-2 px-4 focus:outline-none focus:shadow-outline");
      add_location(button, file49, 12, 0, 349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*toggle*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(12:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block9(ctx) {
  let button;
  let textContent = "True";
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      button.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button) !== "svelte-1n1uhky") button.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "w-full bg-green-500 hover:bg-green-700 active:bg-green-900 text-white font-bold py-2 px-4 focus:outline-none focus:shadow-outline");
      add_location(button, file49, 10, 0, 161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*toggle*/
          ctx[2],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(10:0) {#if  obj[bool_prop] ==true}",
    ctx
  });
  return block;
}
function create_fragment50(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*obj*/
      ctx2[0][
        /*bool_prop*/
        ctx2[1]
      ] == true
    ) return create_if_block9;
    return create_else_block2;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment50.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance50($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tf", slots, []);
  let { bool_prop } = $$props;
  let { obj } = $$props;
  const toggle = () => {
    $$invalidate(0, obj[bool_prop] = !obj[bool_prop], obj);
  };
  $$self.$$.on_mount.push(function() {
    if (bool_prop === void 0 && !("bool_prop" in $$props || $$self.$$.bound[$$self.$$.props["bool_prop"]])) {
      console.warn("<Tf> was created without expected prop 'bool_prop'");
    }
    if (obj === void 0 && !("obj" in $$props || $$self.$$.bound[$$self.$$.props["obj"]])) {
      console.warn("<Tf> was created without expected prop 'obj'");
    }
  });
  const writable_props = ["bool_prop", "obj"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Tf> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bool_prop" in $$props2) $$invalidate(1, bool_prop = $$props2.bool_prop);
    if ("obj" in $$props2) $$invalidate(0, obj = $$props2.obj);
  };
  $$self.$capture_state = () => ({ bool_prop, obj, toggle });
  $$self.$inject_state = ($$props2) => {
    if ("bool_prop" in $$props2) $$invalidate(1, bool_prop = $$props2.bool_prop);
    if ("obj" in $$props2) $$invalidate(0, obj = $$props2.obj);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [obj, bool_prop, toggle];
}
var Tf = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance50, create_fragment50, safe_not_equal, { bool_prop: 1, obj: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tf",
      options,
      id: create_fragment50.name
    });
  }
  get bool_prop() {
    throw new Error("<Tf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bool_prop(value) {
    throw new Error("<Tf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get obj() {
    throw new Error("<Tf>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set obj(value) {
    throw new Error("<Tf>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tf_default = Tf;

// node_modules/sveltetools_bils/src/cmp/ToolBarBtn.svelte
var { console: console_17 } = globals;
var file50 = "node_modules/sveltetools_bils/src/cmp/ToolBarBtn.svelte";
function create_fragment51(ctx) {
  let div;
  let button;
  let span0;
  let t0_value = `${/*icon*/
  ctx[0]}`;
  let t0;
  let t1;
  let span1;
  let t2_value = `${/*title*/
  ctx[1]}`;
  let t2;
  let span1_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      span0 = claim_element(button_nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(button_nodes);
      span1 = claim_element(button_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, t2_value);
      span1_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "text-2xl");
      add_location(span0, file50, 14, 4, 382);
      attr_dev(span1, "class", span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx[2] == true ? (
        /*trueColor*/
        ctx[4]
      ) : (
        /*falseColor*/
        ctx[5]
      )));
      add_location(span1, file50, 15, 4, 428);
      attr_dev(button, "class", button_class_value = `w-full flex flex-col items-center p-2 bg-gray-700 rounded hover:bg-gray-900 active:bg-gray-500`);
      add_location(button, file50, 12, 2, 244);
      attr_dev(div, "class", "w-20");
      add_location(div, file50, 11, 1, 223);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      append_hydration_dev(button, span0);
      append_hydration_dev(span0, t0);
      append_hydration_dev(button, t1);
      append_hydration_dev(button, span1);
      append_hydration_dev(span1, t2);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          function() {
            if (is_function(
              /*clk*/
              ctx[3]
            )) ctx[3].apply(this, arguments);
          },
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*icon*/
      1 && t0_value !== (t0_value = `${/*icon*/
      ctx[0]}`)) set_data_dev(t0, t0_value);
      if (dirty & /*title*/
      2 && t2_value !== (t2_value = `${/*title*/
      ctx[1]}`)) set_data_dev(t2, t2_value);
      if (dirty & /*tf, trueColor, falseColor*/
      52 && span1_class_value !== (span1_class_value = "text-sm font-medium " + /*tf*/
      (ctx[2] == true ? (
        /*trueColor*/
        ctx[4]
      ) : (
        /*falseColor*/
        ctx[5]
      )))) {
        attr_dev(span1, "class", span1_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment51.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance51($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ToolBarBtn", slots, []);
  let { icon = "icon" } = $$props;
  let { title = "Title" } = $$props;
  let { tf = true } = $$props;
  let { clk = () => console.log("Toolbar Btn") } = $$props;
  let { trueColor = "text-green-400" } = $$props;
  let { falseColor = "text-red-400" } = $$props;
  const writable_props = ["icon", "title", "tf", "clk", "trueColor", "falseColor"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console_17.warn(`<ToolBarBtn> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  $$self.$capture_state = () => ({
    icon,
    title,
    tf,
    clk,
    trueColor,
    falseColor
  });
  $$self.$inject_state = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(0, icon = $$props2.icon);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
    if ("tf" in $$props2) $$invalidate(2, tf = $$props2.tf);
    if ("clk" in $$props2) $$invalidate(3, clk = $$props2.clk);
    if ("trueColor" in $$props2) $$invalidate(4, trueColor = $$props2.trueColor);
    if ("falseColor" in $$props2) $$invalidate(5, falseColor = $$props2.falseColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [icon, title, tf, clk, trueColor, falseColor];
}
var ToolBarBtn = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance51, create_fragment51, safe_not_equal, {
      icon: 0,
      title: 1,
      tf: 2,
      clk: 3,
      trueColor: 4,
      falseColor: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToolBarBtn",
      options,
      id: create_fragment51.name
    });
  }
  get icon() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icon(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tf() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tf(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clk() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clk(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trueColor() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trueColor(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get falseColor() {
    throw new Error("<ToolBarBtn>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set falseColor(value) {
    throw new Error("<ToolBarBtn>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ToolBarBtn_default = ToolBarBtn;

// node_modules/sveltetools_bils/src/cmp/Ul.svelte
var file51 = "node_modules/sveltetools_bils/src/cmp/Ul.svelte";
function create_fragment52(ctx) {
  let div1;
  let div0;
  let t0;
  let div0_class_value;
  let t1;
  let div1_class_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(
        /*title*/
        ctx[2]
      );
      t1 = space();
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*title*/
        ctx[2]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (default_slot) default_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = ` mx-4 inline-block ${/*hdgBgColor*/
      ctx[1]}  p-2 m-2 rounded-md
`);
      add_location(div0, file51, 12, 0, 209);
      attr_dev(div1, "class", div1_class_value = ` ${/*bgColor*/
      ctx[0]} border-white border-2 p-1 m-1 rounded-md mx-4 pb-2
`);
      add_location(div1, file51, 8, 0, 125);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div1, t1);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*title*/
      4) set_data_dev(
        t0,
        /*title*/
        ctx2[2]
      );
      if (!current || dirty & /*hdgBgColor*/
      2 && div0_class_value !== (div0_class_value = ` mx-4 inline-block ${/*hdgBgColor*/
      ctx2[1]}  p-2 m-2 rounded-md
`)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*bgColor*/
      1 && div1_class_value !== (div1_class_value = ` ${/*bgColor*/
      ctx2[0]} border-white border-2 p-1 m-1 rounded-md mx-4 pb-2
`)) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment52.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance52($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Ul", slots, ["default"]);
  let { bgColor = "bg-gray-700" } = $$props;
  let { hdgBgColor = "bg-gray-900" } = $$props;
  let { title = "Title" } = $$props;
  const writable_props = ["bgColor", "hdgBgColor", "title"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Ul> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("hdgBgColor" in $$props2) $$invalidate(1, hdgBgColor = $$props2.hdgBgColor);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
    if ("$$scope" in $$props2) $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ bgColor, hdgBgColor, title });
  $$self.$inject_state = ($$props2) => {
    if ("bgColor" in $$props2) $$invalidate(0, bgColor = $$props2.bgColor);
    if ("hdgBgColor" in $$props2) $$invalidate(1, hdgBgColor = $$props2.hdgBgColor);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bgColor, hdgBgColor, title, $$scope, slots];
}
var Ul = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance52, create_fragment52, safe_not_equal, { bgColor: 0, hdgBgColor: 1, title: 2 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Ul",
      options,
      id: create_fragment52.name
    });
  }
  get bgColor() {
    throw new Error("<Ul>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bgColor(value) {
    throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hdgBgColor() {
    throw new Error("<Ul>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hdgBgColor(value) {
    throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<Ul>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<Ul>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Ul_default = Ul;
export {
  Anchor_default as Anchor,
  AnchorIconOval_default as AnchorIconOval,
  AreYouSure_default as AreYouSure,
  BtnIconOval_default as BtnIconOval,
  BtnIconRound_default as BtnIconRound,
  BtnWIcon_default as BtnWIcon,
  BtnWIconSm_default as BtnWIconSm,
  BtnWIconXs_default as BtnWIconXs,
  Card_default as Card,
  CardBtn_default as CardBtn,
  CardImg_default as CardImg,
  CardOnly_default as CardOnly,
  Centre_default as Centre,
  CodeComp_default as CodeComp,
  Comment_default as Comment,
  DDDivs_default as DDDivs,
  Footer_default as Footer,
  FormElm_default as FormElm,
  FormRow_default as FormRow,
  HdgWithIcon_default as HdgWithIcon,
  Img_default as Img,
  InputElm_default as InputElm,
  InputEmail_default as InputEmail,
  InputForm_default as InputForm,
  InputFormCancel_default as InputFormCancel,
  InputTextArea_default as InputTextArea,
  Lbl_default as Lbl,
  Li_default as Li,
  LinkIconOval_default as LinkIconOval,
  Loading_default as Loading,
  Logo_default as Logo,
  NavBar_default as NavBar,
  NavBtn_default as NavBtn,
  NavBtn2_default as NavBtn2,
  NavLink_default as NavLink,
  NavSec_default as NavSec,
  NumberElm_default as NumberElm,
  P_default as P,
  PageNav_default as PageNav,
  PageNavBtn_default as PageNavBtn,
  PageNavLink_default as PageNavLink,
  PageWrapper_default as PageWrapper,
  ProgressBar_default as ProgressBar,
  Range_default as Range,
  SectionHead_default as SectionHead,
  SectionHeadAYS_default as SectionHeadAYS,
  SectionHeadIcon_default as SectionHeadIcon,
  ShowIfTrue_default as ShowIfTrue,
  SmallBtnToolbar_default as SmallBtnToolbar,
  Tf_default as Tf,
  ToolBarBtn_default as ToolBarBtn,
  Ul_default as Ul
};
//# sourceMappingURL=sveltetools_bils_src_cmp.js.map
